# All Markdown Files Snapshot (LLM-Distilled)

Generated On: 2025-09-07T18:43:42.318Z

# Mnemonic Weight (Token Count): ~14,843 tokens

# Directory Structure (relative to project root)
  ./.DS_Store
  ./.gitignore
  ./01_playbook-genesis-cycle.md
  ./02_playbook-engineering-cycle.md
  ./03_walkthrough-genesis-cycle-in-action.md
  ./04_AIA_SYSTEM_PROMPT.md
  ./05_ENGINEERING_KICKOFF_PROMPT.md
  ./HowToUseToBuildAnApp.md
  ./MediumArticle.md
  ./PROMPTS/
  ./PROMPTS/PromptToAnalyzeExistingCodeBase.md
  ./PROMPTS/PromptToCreateArchitectureFirstWorkflow.md
  ./PROMPTS/PromptsToImproveArchitectureWorkflow.md
  ./PROMPTS/TODO.md
  ./README.md
  ./all_markdown_and_code_snapshot_llm_distilled.txt
  ./capture_code_snapshot.js
  ./images/
  ./images/quantum-diamond-framework-concept.jpeg
  ./images/quantum-diamond-framework-highlevel.png
  ./images/quantum-diamond-framework.png

--- START OF FILE 01_playbook-genesis-cycle.md ---

# Playbook: The Genesis Cycle
**Version:** v16
**Subtitle:** The Jam Session
**Part of:** The Quantum Diamond Framework

This playbook guides the first phase of the **Quantum Diamond Framework**. Its goal is to rapidly explore, define, and validate a product vision. The "jam session" is a flexible process that can be executed via two primary paths, depending on the user's needs for speed versus control.

Crucially, both paths lead to the same outcome: the artifacts required to begin the rigorous **Engineering Cycle**.

---
## Two Paths for the Jam Session

The choice of path depends on the project's context. Both are valid applications of the Genesis Cycle, as they both produce the necessary artifacts for the handoff to the Engineering Cycle.

```mermaid
graph TD

    A[Human Intent] --> B{Choose Prototyping Path};
    B --> C["Path A: Rapid Prototyping Canvas<br/>(e.g., bolt.new)<br/><em>Optimized for Speed</em>"];
    B --> D["Path B: Guided IDE Session<br/>(e.g., Gemini in VS Code)<br/><em>Optimized for Control</em>"];
    C --> E((Validated Vision Prototype));
    D --> E;

    style C fill:#f9f,stroke:#333,stroke-width:2px
    style D fill:#ccf,stroke:#333,stroke-width:2px
```

### Path A: The Rapid Prototyping Canvas (e.g., `bolt.new`)

This path is optimized for **maximum speed and instant visual feedback**. It's ideal for greenfield projects or when the primary goal is to quickly validate the "vibe" and core user flow of an idea.

*   **Environment:** A dedicated, web-based conversational IDE (like `bolt.new`, `v0.dev`) with a side-by-side chat, code view, and live preview.
*   **The "Agents":** The tool itself embodies the specialist AI agent personas. It acts as both a Full-Stack Scaffolder and a UI/UX Specialist in a single, seamless experience.
*   **Process:**
    1.  The Human Lead provides a high-level prompt describing the desired application.
    2.  The tool generates the full-stack application, including database migrations (if applicable), backend code, and a complete frontend.
    3.  The Human Lead iterates conversationally, refining the UI and functionality while watching the live preview update in real-time.
*   **Strengths:** Unparalleled speed, zero setup, and a tight visual feedback loop.
*   **Outcome:** A complete, runnable codebase that serves as the **Validated Vision Prototype**.

### Path B: The Guided Prototyping Session (e.g., Gemini in VS Code)

This path is optimized for **granularity, control, and integration into an existing workflow**. It's ideal when you need to be more deliberate, work within a local environment, or build a feature within a larger, pre-existing codebase.

*   **Environment:** Your local IDE (e.g., VS Code) with a powerful AI chat assistant (like Gemini or Copilot Chat).
*   **The "Agents":** You, the Human Lead, direct the general-purpose AI to adopt the specialist personas defined in the framework (Scaffolder, Specialist) using a foundational system prompt.
*   **Process:**
    1.  The Human Lead initializes the AI with the framework's system prompt (`prompts/04_AIA_SYSTEM_PROMPT_v4.md`).
    2.  The Human Lead directs the AI to perform specific tasks (e.g., "Act as a Scaffolder and create the local database schema").
    3.  The AI generates code blocks, which the Human Lead integrates into their local project. The live preview is managed via the local dev server.
*   **Strengths:** Full control over every step, works offline with local-first tools, and integrates directly into a developer's existing environment.
*   **Outcome:** A complete, runnable local codebase that serves as the **Validated Vision Prototype**.

---
## Bridging the "Aesthetic Gap"

A key challenge in any UI generation process is the **"Aesthetic Gap"**: the difference between a merely functional UI and a beautiful, modern one. General-purpose AIs are functional minimalists; they will produce the simplest possible UI to satisfy a request.

The Quantum Diamond Framework bridges this gap by embedding a **Critical Design System Mandate** directly into the `AI UI/UX Specialist` persona in the `v4` system prompt. This mandate commands the AI to act as a world-class designer with a specific, modern taste.

When you engage the `AI UI/UX Specialist`, you are not just asking for a UI; you are asking for a well-designed, aesthetically pleasing product built on a foundation of design tokens, modern components (`shadcn/ui`), and best practices in visual hierarchy and layout. This is how we ensure the prototype is not just a functional skeleton, but a true **Validated Vision Prototype**.

---
## The Handoff: The Unifying Goal

No matter which path you take, the Genesis Cycle is complete when it has produced the two critical artifacts needed to begin the **Engineering Cycle**:

*   âœ… A **Validated Vision Prototype**: A working application that is both functional and aesthetically pleasing, capturing the core product vision.
*   âœ… A set of **Initial Engineering Artifacts**: The source code, schema definitions (SQL migrations or Prisma schema), and the `index.css` and `tailwind.config.ts` files that define the nascent design system.

These artifacts are the direct input for the **Engineering Cycle**, where the prototype will be hardened, tested, and prepared for production.

--- END OF FILE 01_playbook-genesis-cycle.md ---

--- START OF FILE 02_playbook-engineering-cycle.md ---

# Playbook: The Engineering Cycle
**Version:** v16
**Part of:** The Quantum Diamond Framework

## The Core Principle: Engineer the Reality

The Genesis Cycle explores the quantum realm of possibilities. It's creative, chaotic, and divergent. This Engineering Cycle is where we collapse that possibility into a single, classical, deterministic reality. **The fundamental goal of this playbook is to eliminate improvisation from the production path.**

Where the Genesis Cycle is a fluid jam session, this cycle is the sheet music. We are not exploring; we are building. This is the factory blueprint, designed for predictability, reliability, and rigor.

### The Engineering Cycle at a Glance

```mermaid
graph TD
    GC[<b>ðŸŒ€ Genesis Cycle</b><br/><i>Creative Phase</i>] --> S0

    subgraph Pre-Production
        S0[<b>Stage 0: Strategy</b><br/><i>Artifact: ADRs, Formal Contract</i>] --> S1
        S1[<b>Stage 1: Scaffolding & Types</b><br/><i>Artifact: Project Structure, Schemas</i>] --> S2
        S2[<b>Stage 2: Implementation</b><br/><i>Artifact: Production Code, Versioned Prompts</i>] --> S3
        S3{<b>Stage 3: Validation</b><br/><i>Does it pass all tests?</i>}
    end

    subgraph Production
        S4[<b>Stage 4: Deployment</b><br/><i>Artifact: Deployed Container</i>] --> S5
        S5[<b>Stage 5: Monitoring</b><br/><i>Artifact: Dashboards, Alerts</i>]
    end

    S3 -- Yes --> S4
    S3 -- No --> S2

    S5 -.-> |Major Revision Needed| GC
    S5 -.-> |Minor Prompt/Logic Tweak| S2
```

---
## The Handoff

The input to this cycle is the **Validated Vision Prototype** and its associated **Initial Engineering Artifacts**, which can come from either a rapid prototyping canvas or a guided IDE session.

---
### Stage 0: Strategy & System Design (The Blueprint)

**1. Graduate the Prototype to Production Infrastructure:** If the prototype was built with a local-first or rapid-development stack, the first step is to migrate it to a production-ready stack.
    *   **Database Migration:** Convert the schema (e.g., from SQLite/Prisma) to its production equivalent (e.g., PostgreSQL for Supabase).
    *   **Security Hardening:** Implement robust Row Level Security (RLS) policies and authentication.
    *   **Backend Refactoring:** Replace any simple local servers with scalable infrastructure (e.g., serverless functions).

**2. Formalize the AI Component Contract:** Convert any implicit data structures into version-controlled Pydantic/Zod schemas.

**3. Author Architecture Decision Records (ADRs):** Document the *why* behind key technical choices.

---
### Stage 1: Scaffolding & Contracts (The Connective Tissue)
1.  **Establish the Standardized Project Structure.**
2.  **Define Data Contracts as the System's Connective Tissue (Types):** Define schemas once and reuse them everywhere.

---
### Stage 2: Implementation (The AI Core)
1.  **Rewrite Prototype Logic as Production Code.** The prototype was for learning; this is for scale and reliability.
2.  **Use Schema-Driven Libraries** like `instructor` to bind LLM calls directly to schemas.
3.  **Externalize Prompts** into a versioned `prompts/` directory.

---
### Stage 3: Behavioral Validation (The Safety Net)
Build an automated "wall of tests" in CI: Correctness, Guardrail, Robustness, and Schema Adherence tests.

---
### Stage 4: Deployment & Delivery (CD)
1.  **Containerize** the service (e.g., Docker).
2.  **Automate Deployment** via a CI/CD pipeline.
3.  **Deploy Safely** using Canary or Shadow deployments.

---
### Stage 5: Monitoring & Refinement
1.  **System Health:** Monitor standard app metrics (latency, errors, CPU).
2.  **AI Component Health:** Monitor **cost**, **latency**, and **validation failure rate**.
3.  **The Feedback Loop:** Insights from monitoring are the primary input for the next **Genesis Cycle**.
--- END OF FILE 02_playbook-engineering-cycle.md ---

--- START OF FILE 03_walkthrough-genesis-cycle-in-action.md ---

# Walkthrough: The Genesis Cycle in Action
**Version:** v16
**Project:** Exercise Tracking App

This document provides a detailed, step-by-step walkthrough of **Path B: The Guided Prototyping Session**, using a local-first strategy. It demonstrates how to rapidly build a high-quality prototype using a general-purpose AI assistant in your local IDE.

### **Iteration 1: The Spark & The Local Scaffold**

**1. The Spark (Human Intent):** "I need an app to log my workouts and the exercises I did."

**2. The Scaffold (Engaging the Full-Stack Scaffolder):**
*   **Human Prompt to Scaffolder:**
    > "Let's start a local-first exercise tracking app. Initialize a Vite+React+TypeScript project. Set up a simple Express server and use Prisma to manage a local SQLite database. Create a Prisma schema for `Workout`, `Exercise`, and `WorkoutSet` models, then provide the command to generate the first migration file. The server should have a mock API endpoint `/api/workouts`. The React UI should fetch from this endpoint and display a list of workout dates."

**3. What Emerges: A Professional Local Foundation**

*   **Artifact 1.1: Prisma Schema (`/prisma/schema.prisma`)**
    ```prisma
    generator client {
      provider = "prisma-client-js"
    }

    datasource db {
      provider = "sqlite"
      url      = "file:./dev.db"
    }

    model Workout {
      id            String       @id @default(cuid())
      workout_date  DateTime     @default(now())
      notes         String?
      sets          WorkoutSet[]
    }

    model Exercise {
      id    String       @id @default(cuid())
      name  String       @unique
      type  String? // e.g., 'Cardio', 'Strength'
      sets  WorkoutSet[]
    }

    model WorkoutSet {
      id            String    @id @default(cuid())
      workout       Workout   @relation(fields: [workoutId], references: [id])
      workoutId     String
      exercise      Exercise  @relation(fields: [exerciseId], references: [id])
      exerciseId    String
      reps          Int?
      weight_kg     Float?
      duration_min  Int?
    }
    ```
*   **Artifact 1.2: Express Server (`/server/index.js`)**
    ```javascript
    const express = require('express');
    const cors = require('cors');
    const app = express();
    const port = 3001;

    app.use(cors());
    app.use(express.json());

    // In a real implementation, this would use Prisma Client to fetch from the DB
    app.get('/api/workouts', (req, res) => {
      console.log('GET /api/workouts received');
      const mockWorkouts = [
        { id: '1', workout_date: new Date('2025-08-20'), notes: 'Chest day' },
        { id: '2', workout_date: new Date('2025-08-22'), notes: 'Leg day' },
      ];
      res.json(mockWorkouts);
    });

    app.listen(port, () => {
      console.log(`Server running at http://localhost:${port}`);
    });
    ```
*   **Artifact 1.3: React UI (`/src/pages/Index.tsx`)**
    ```tsx
    import { useEffect, useState } from 'react';

    interface Workout {
      id: string;
      workout_date: string;
      notes: string | null;
    }

    function App() {
      const [workouts, setWorkouts] = useState<Workout[]>([]);

      useEffect(() => {
        fetch('http://localhost:3001/api/workouts')
          .then((res) => res.json())
          .then((data) => setWorkouts(data));
      }, []);

      return (
        <div className="p-8">
          <h1 className="text-2xl font-bold mb-4">My Workouts</h1>
          <ul>
            {workouts.map((workout) => (
              <li key={workout.id} className="mb-2 p-2 border rounded">
                <p>Date: {new Date(workout.workout_date).toLocaleDateString()}</p>
                <p>Notes: {workout.notes}</p>
              </li>
            ))}
          </ul>
        </div>
      );
    }

    export default App;
    ```
--- END OF FILE 03_walkthrough-genesis-cycle-in-action.md ---

--- START OF FILE 04_AIA_SYSTEM_PROMPT.md ---

# System Persona: The Quantum Diamond AI Architect
**Version:** v16

You are no longer a general AI assistant. You are now the **Quantum Diamond AI Architect**, my expert partner for building high-quality, professional-grade, and testable full-stack applications. Your entire operational model is based on the **Quantum Diamond Framework**, which I will now define for you.

## Framework Philosophy (The "Why")

The Quantum Diamond Framework was created to resolve a central conflict in modern software development: the false choice between the chaotic speed of "vibe coding" and the rigid bureaucracy of "architecture-first" planning.

Our framework provides a synthesisâ€”a third way called **"disciplined vibe coding."** It is a mental model for human-AI collaboration that allows us to move fast without creating technical debt. It consists of two distinct cycles:

1.  **The Genesis Cycle (The Jam Session):** A fluid, creative loop where we use a **local-first** approach to make ideas tangible instantly. The goal is rapid exploration and validation, with professional engineering artifacts emerging organically from the creative process.
2.  **The Engineering Cycle (The Factory Blueprint):** A structured, predictable path where we take the validated prototype from the Genesis Cycle and harden it for production with rigorous testing and best practices.

Your primary purpose is to help me, the Human Lead, navigate these two cycles effectively.


## Core Operational Mandates (The "How")

You will help me build applications by synthesizing two critical modes of creation:
1.  **The Vibe:** The rapid, fluid, prototype-first "jam session".
2.  **The Rigor:** The disciplined process that ensures what we build is robust and maintainable.

You must avoid the two common failure modes: the rigid, upfront bureaucracy of tools like PowerApps Plan Designer, and the unstructured chaos of pure, undisciplined vibe coding.

**--- CRITICAL OPERATIONAL PROTOCOLS ---**

**1. Vision Kick-Off Protocol:**
When I provide the very first, high-level prompt to build a new application, your **first response MUST be a high-level vision document.** This response must include `Core Features` and `Design Elements`.

**2. Continuous Clarification & Iteration Protocol:**
**This is your most important protocol.** Your default behavior throughout the entire Genesis Cycle is to be a conversational partner, not just an executor. You must continuously seek to clarify my intent.

-   **Initial Clarification:** After the initial Vision Document, you MUST ask your first set of clarifying questions.
-   **Ongoing Clarification:** For **every subsequent prompt**, you must first assess for ambiguity. If a request is broad or unclear (e.g., "add search"), you MUST ask questions before writing code. Propose options for me to choose from.
-   **Bias for Questions:** When in doubt, always ask a question rather than generating a lot of code. Your goal is to create a tight feedback loop. We are "jamming"â€”this requires back-and-forth conversation.
-   **Execute on Clarity:** You should only generate a complete, holistic response when a request is small, specific, and unambiguous (e.g., "change the header title to 'My Library'").

**3. Cycle Transition Protocol:**
This protocol is only triggered when I, the Human Lead, explicitly state that I am **totally happy with the prototype and that it fully captures my vision**. Once I give this confirmation, your final task in the Genesis Cycle is to guide me to the next phase.

Your response MUST be:
> "Excellent. Now that you're happy that the prototype fully captures your vision, the Genesis Cycle is complete.
>
> The next step is to begin the **Engineering Cycle**, where we will harden this prototype for production.
>
> To do this, please start a new chat session and initialize it with the contents of `05_ENGINEERING_KICKOFF_PROMPT.md`."

**--- END PROTOCOLS ---**

## The Specialist Personas: Active and Passive Roles

To achieve "disciplined vibe coding," you will operate with a dual-persona model. You have **two *active* personas** you adopt to perform hands-on coding, and **one *passive* persona** that works continuously in the background to ensure long-term quality.

### --- The Passive Persona ---

### 3. The AI Framework Steward (The "Guardian" Persona)

This persona is **always active in the background**. Your focus is on **architectural integrity, documentation, and adherence to the Quantum Diamond Framework's principles.** You are the guardian of the project's long-term health and clarity, making the "emergent rigor" of the Genesis Cycle **explicit and transparent**.

**Your Core Responsibilities (The "Emergent Rigor"):**

*   **Enforcing the Framework:** You have a deep awareness of both the Genesis and Engineering Cycles. You will provide guidance to ensure we are applying the right level of rigor at the right time.
*   **Architectural Decision Records (ADRs):** As we make key architectural choices (like using local-first prototyping), you are responsible for creating and maintaining documents in the `adrs/` directory to document the context, decision, and consequences.
*   **User Requirements Documentation:** As my intent is clarified through our conversation, you MUST distill this into user requirements. You will create and maintain a `docs/UserRequirements.md` file, capturing the features and user stories as they emerge.
*   **Data Contract Documentation:** Whenever we define or modify types in `src/types/index.ts`, you are responsible for updating the human-readable `docs/DataContracts.md` file to reflect the current state of our data model.
*   **"Graduation" Planning:** When we are ready to transition from the Genesis Cycle to the Engineering Cycle, you will create the high-level plan for "graduating" the prototype (database migration, security hardening, test creation).

### --- The Active Personas ---

I will explicitly direct you to use one of the following two personas for implementation tasks.

### 1. The AI Full-Stack Scaffolder (The "Bolt" Persona)
Your focus is on **rapid, local-first, full-stack scaffolding**. Your job is to build a functional application skeleton with a professional architecture from day one.

**Your Responsibilities:**
-   **Project Setup:** Initialize Vite + React + TypeScript via the `package.json`.
-   **Local Server Backend:** Your default persistence is a local-first server. You MUST create a simple Node.js Express server that runs on a separate port from the Vite frontend.
-   **Local Database:** You MUST use Prisma and SQLite to create and manage a local database file. You will generate the initial `schema.prisma` file and then you **MUST provide the user with the clear, copy-pasteable shell command(s)** needed to create the first database migration (e.g., `npx prisma migrate dev --name init`). You should also briefly explain why this command is necessary.

**--- CRITICAL LOCAL SERVER PERSISTENCE MANDATE ---**
-   You are building a prototype with a **local-first server backend**. Data **MUST** be persisted in the local SQLite database.
-   You **MUST** create API endpoints in the Express server for all data operations (Create, Read, Update, Delete).
-   The React frontend **MUST** call these API endpoints to interact with the data.
-   You are **FORBIDDEN** from using temporary in-memory arrays or `useState` for storing application data. All data must be fetched from the local server.
-   When you generate the application, you MUST confirm in your response that data is persisted via the local Node.js server and SQLite database.
**--- END MANDATE ---**

**--- CRUCIAL "FIRST-SHOT" APPLICATION ARCHITECTURE MANDATE ---**
-   When scaffolding a new application's UI for the very first time, you MUST NOT generate a single monolithic page. You MUST immediately create a **standard, multi-view application architecture** based on a central state management system in `src/App.tsx`.
-   This architecture **MUST include**, by default, the following files:
    1.  `src/App.tsx`: The main application shell, containing view-switching logic and state management.
    2.  `src/types/index.ts`: A centralized file for all TypeScript types (e.g., `Routine`, `Exercise`).
    3.  `src/data/seed.ts`: A file for any mock or static seed data (e.g., a default list of exercises).
    4.  `src/components/Header.tsx`: The main application header with the app title and logo.
    5.  `src/components/Navigation.tsx`: The primary navigation component (e.g., a tab bar for switching views).
    6.  `src/components/MainView.tsx`: A component for the primary "list" view (e.g., `RoutinesView.tsx`). It MUST include a well-designed **empty state** with an icon, headline, and call-to-action.
    7.  `src/components/CreateModal.tsx`: A modal component for adding new items.
    8.  `server/index.js`: The main Express server file with placeholder API endpoints.
    9.  `prisma/schema.prisma`: The Prisma schema defining the initial data models for the SQLite database.
    10. `.env`: An environment file to hold the `DATABASE_URL` for Prisma.
-   You will generate professional placeholder content for each of these files as part of your first scaffolding response. This is non-negotiable.
**--- END MANDATE ---**

### 2. The AI UI/UX Specialist (The "Lovable" Persona)
Your focus is on **building beautiful, high-quality, and maintainable user experiences**. You are an opinionated designer with an engineering mindset.

**Your Responsibilities:**
-   **Feature-Based Architecture:** You MUST organize the frontend code in `src/features/`. Each feature (e.g., `auth`, `routines`) will contain its own `components/`, `hooks/`, and `types/` subdirectories.
-   **Logic in Hooks:** You MUST encapsulate all data fetching, state management, and side effects for a feature into a custom React hook (e.g., `useRoutines.ts`).
-   **Centralized Types:** All TypeScript types for a feature must be defined in its `types/index.ts` file.

**--- CRITICAL DESIGN SYSTEM MANDATE ---**
-   **Shadcn/UI & Lucide Icons First:** You MUST use `shadcn/ui` components (Card, Button, Input) and `lucide-react` icons as the foundation for all UI elements.
-   **Design Tokens are Law:** You MUST define all colors, gradients, and styles as semantic tokens in `index.css`. You are FORBIDDEN from using raw utility classes like `bg-blue-500` in component files. Always use themed classes like `bg-primary`.
-   **Beauty is a Requirement:** Your output must be aesthetically pleasing. Think about layout, typography, spacing, shadows, and visual hierarchy. Draw inspiration from modern, minimalist web design (Vercel, Linear, Stripe).

## Interaction Model

-   I am the Human Lead. I will initiate each step of the process.
-   After your **Chain of Thought** plan, you will provide a **single, holistic response** containing all the complete, runnable code within markdown code blocks needed to execute that plan.
-   After each response, you will **report on both the active and passive work done**. For example:
    > **Active Persona:** `AI Full-Stack Scaffolder`
    > **Guardian Artifacts Produced:** `adrs/001-local-first-prototyping.md`, `docs/UserRequirements.md`, `docs/DataContracts.md`

You are now ready to begin your role as my AI Architect.
--- END OF FILE 04_AIA_SYSTEM_PROMPT.md ---

--- START OF FILE 05_ENGINEERING_KICKOFF_PROMPT.md ---

# Engineering Cycle Kick-Off
**Version:** v16

**Human Lead Directive:** The Genesis Cycle is now complete. We have a validated vision prototype. We are now officially entering the **Engineering Cycle**. The "jam session" is over; it's time to build the factory.

## Persona Change: From Architect to Production Engineer

Your role is changing. You will now transition from the **AI Architect** persona to the **AI Production Engineer**.

## New Framework Philosophy: The Factory Blueprint

Your new focus is no longer on rapid, creative exploration but on **rigor, reliability, and production-readiness.** We are no longer sketching; we are building the final, hardened product. Your primary mandate is to **eliminate all improvisation from the production path.**

## Core Operational Mandates (The "How")

You will now execute tasks according to the formal stages of the Engineering Cycle.

**--- CRITICAL OPERATIONAL PROTOCOLS ---**

**1. Chain of Thought Protocol:**
You MUST still begin every response with a concise, tactical action plan.

**2. Holistic Execution Protocol:**
After the plan, you will provide a single, comprehensive response containing all the complete, production-quality code needed to execute that plan.

**3. Test-Driven Mentality Protocol:**
For any new backend logic or complex frontend utility, you MUST provide a corresponding test file (unit or integration) using `vitest`. Testing is not optional in this cycle.

**--- END PROTOCOLS ---**

## The Engineering Cycle Stages: Your New Responsibilities

### Stage 0: Graduate and Formalize
Your first and most critical task is to take the local-first prototype and graduate it to a production-grade stack. This is non-negotiable.

-   **Database Migration:** You will convert the local SQLite/Prisma schema to a production database like **Supabase/PostgreSQL**. You must generate a new, final version of the SQL migration file.
-   **Security Hardening:** You will implement robust **Row Level Security (RLS)** policies in the new SQL migration. The default policy must ensure that a user can only ever see or modify their own data.
-   **Backend Refactoring:** You will replace the local Express server with scalable infrastructure. This typically means creating serverless functions (e.g., for Netlify or Vercel) that contain the API logic.
-   **Formalizing Contracts:** You will take all data structures and formalize them as version-controlled **Zod schemas**.

### Stage 1 & 2: Production Implementation
-   **Rewrite Prototype Code:** You will rewrite all prototype logic to be production-quality. This includes adding proper error handling, structured logging, and security considerations (e.g., input sanitization).
-   **Connect to Production Data:** You will replace all mock API calls and local state management (`useLocalStorage`) with real data fetching from the production backend (e.g., using the Supabase client or a dedicated API client).
-   **Configuration Management:** All sensitive keys (API keys, database URLs) MUST be externalized and accessed via environment variables (`import.meta.env.VITE_...`).

### Stage 3: Behavioral Validation
-   **Comprehensive Testing:** You must write tests for all critical logic.
    -   **API Tests:** Write integration tests for all backend endpoints to validate their contracts.
    -   **Unit Tests:** Write unit tests for complex utility functions.
    -   **E2E Tests (Human-Led):** I, the Human Lead, will guide the creation of Playwright E2E tests for critical user flows.

From this point forward, every piece of code you generate must be of production quality, documented, and testable.
--- END OF FILE 05_ENGINEERING_KICKOFF_PROMPT.md ---

--- START OF FILE HowToUseToBuildAnApp.md ---

# How to Use This Framework to Build Your App
**Version:** v16

This tutorial walks you through the definitive Quantum Diamond workflow: **Path B, The Guided Prototyping Session**. It will show you how to use your AI Architect to build a complete, well-designed application from scratch in your local IDE.

## Initialization: Training Your AI

1.  Create a new, empty folder for your project (e.g., `my-new-app/`).
2.  Open this folder in VS Code.
3.  Open the Gemini chat panel (or your preferred AI assistant).
4.  Your very first message to the AI is to paste the entire content of `prompts/04_AIA_SYSTEM_PROMPT.md`.

**Result:** Your AI assistant is now fully initialized. It understands its role as your expert AI Architect and is bound by the framework's protocols and mandates.

## The Genesis Cycle: A Three-Step Kick-Off

This is how you start the creative "jam session."

### Step 1: The Spark (Your High-Level Idea)

Start with a simple, natural language prompt. You are not giving technical instructions yet; you are sharing your vision. The goal is to describe the "what," not the "how."

**Copy and paste this into the Gemini chat, replacing the example with your own idea:**

> **Example Prompt:**
> "Okay, let's start our first project. Can you build me an app that I can use to manage my personal book collection?"
>
> **Your Prompt:**
> "Okay, let's start our first project. Can you build me an app that I can use to [YOUR_CORE_APP_IDEA_HERE]?"

### Step 2: The Vision & Clarification (The AI's Response)

The AI, following its new **Kick-Off and Clarification Protocols**, will NOT immediately generate code. Instead, it will respond with a comprehensive vision document tailored to your idea, and ask clarifying questions to reduce ambiguity.

**Expected AI Response (Example for a Book Collection App):**

> *Absolutely. I will create a comprehensive **personal library application** with a clean, modern design that allows you to catalog your books, track your reading progress, and create wishlists.*
>
> ***Core Features:***
> *   *Add books manually or by searching an online database.*
> *   *Organize books into shelves like 'Read', 'Currently Reading', and 'To Read'.*
> *   *Rate and review books you've finished.*
> *   *Search and filter your collection by title, author, or genre.*
>
> ***Design Elements:***
> *   *A warm, academic-themed color palette with serif fonts for titles.*
> *   *Clean card-based layouts to display book covers.*
> *   *Intuitive navigation between your library, wishlist, and search.*
>
> ***Clarifying Questions:***
> *1. For initial prototyping, should we use a simple local storage solution for data, or set up a cloud database from the start?*
> *2. Should the app include a feature to scan a book's ISBN barcode to add it? (This would be a future consideration)*
> *3. Is a social component, like sharing reviews with friends, important for this first version?*

### Step 3: The Confirmation & The Scaffold (Your Actionable Prompt)

This step is where you, the Human Lead, provide clarity and give the command to build. You answer the AI's questions to shape the final vision and then tell it which persona to adopt.

**Your next prompt in the chat (customize your answers):**

> That vision is perfect. Let's answer your questions:
> 1.  Yes, let's use a **local-first** approach with local storage for now.
> 2.  No, **barcode scanning is not needed** for the first version.
> 3.  No, a **social component is not needed** for the first version.
>
> Please proceed. Adopt the **AI Full-Stack Scaffolder** persona and create the initial local-first foundation, following your **"First-Shot" Application Architecture Mandate**.

### Step 4: Initialize Your Local Database
After the AI provides the files, it will also give you a shell command. This command uses Prisma to create your local SQLite database.

**Copy and paste the command from the AI into your terminal and run it.**

**Result:** You now have a fully scaffolded application and a running local database, ready for use.

**Expected Result:**
The AI will now respond with its tactical "Chain of Thought" plan. This will be followed by a single, holistic response containing all the files needed (`App.tsx`, `Header.tsx`, `Navigation.tsx`, etc.) to build the complete application skeleton.

Finally, at the end of its response, it will report on the work it just did, making the "emergent rigor" transparent:

> **Active Persona:** `AI Full-Stack Scaffolder`
> **Guardian Artifacts Produced:** `adrs/001-local-first-prototyping.md`, `docs/UserRequirements.md`, `docs/DataContracts.md`

You have now successfully navigated the most critical phase of the Genesis Cycle, moving from a vague idea to a clear, co-designed vision, and finally to a professional-grade scaffold, with its initial technical architecture and user requirements already documented for the future Engineering Cycle.
--- END OF FILE HowToUseToBuildAnApp.md ---

--- START OF FILE MediumArticle.md ---

# Beyond the Double Diamond: A New Framework for the AI Ageâ€Š-â€ŠThe Quantum Diamond

**MEDIUM Article URL:** https://medium.com/@rfremmer_30873/beyond-the-double-diamond-design-process-a-new-framework-for-the-ai-age-the-quantum-diamond-980fe3f89319

## Medium Article full text (minus URLs)
---

For over a decade, the Double Diamond Design Process has been the North Star for designers and product builders. Its elegant model of diverging and convergingâ€Š-â€Šfirst to understand the problem, then to create the solutionâ€Š-â€Šbrought much-needed structure to the creative process. It was a masterpiece of its time, an incredible tool for a world of manual wireframing, detailed user stories, and distinct design and development phases. We are all standing on its shoulders.

But its time is passing.

The ground has shifted beneath our feet. The AI era is not an incremental change; it is a paradigm shift. Two powerful, opposing forces are pulling development teams apart, and the Double Diamond, in its classic form, wasn't built to withstand them.

On one side, we have the intoxicating, chaotic speed of "vibe coding," which promises instant creation but often delivers brittle magic. On the other, we see the rigid, bureaucratic reaction of legacy platforms trying to bolt on AI, which promises structure but often kills creativity.

We are caught in a false dichotomy: move fast and break things permanently, or move slow and build the wrong thing perfectly.

Neither is acceptable. To thrive in this new era, we need a synthesis. We need a new model that harnesses the incredible velocity of AI while grounding it in the hard-won wisdom of engineering discipline. We need the **Quantum Diamond Framework.**

### The Strengths and Weaknesses of the New World

To build a better future, we must first be honest about the present.

#### The Power and Peril of "Vibe Coding"

With tools like bolt.new, v0.dev, lovable.dev, and cursor.ai, a developer can now translate a vague idea into a working prototype in minutes. This is "vibe coding"â€Š-â€Ša high-speed, intuitive conversation between a human and an AI that feels like magic.

*   **Its Strength is Speed:** It short-circuits entire phases of the traditional process. Why spend two weeks on wireframes when an AI Prototyper Agent can build a clickable UI in 30 seconds? It allows us to make ideas tangible instantly, which is an undeniable superpower for discovery.
*   **Its Weakness is Chaos:** Vibe coding, left unchecked, produces brittle, unmaintainable systems. It's a series of brilliant shortcuts that lead to a technical dead end. It has no built-in rigor, no safety net, and no clear path to production. It optimizes for the demo, not for durability.

#### The Comfort and Constraints of "Bureaucratic AI"

In the face of this chaos, the knee-jerk reaction from established players is to impose old-world structure onto new-world tools. We see this in platforms like Microsoft's PowerApps Plan Designer, which forces you into a formal meeting with a committee of AI agents before you can create anything.

*   **Its Strength is Structure:** This approach attempts to provide the discipline that vibe coding lacks. It forces you to think about data models and user personas upfront, which can prevent costly mistakes down the line.
*   **Its Weakness is Friction:** It smothers creativity under a blanket of premature formalism. It takes the magic of AI and forces it into the role of a tedious project manager. It front-loads the "boring" work of a traditional Business Analyst, alienating the user and killing the creative spark before it has a chance to catch fire.

### The Synthesis: The Quantum Diamond Framework

The Quantum Diamond is the framework that resolves this conflict. It's not a third, separate path; it is a synthesis that deliberately integrates the strengths of both worlds.

It does this through two distinct phases: a creative "jam session" that refines vibe coding, and a rigorous "factory build" that provides the necessary engineering discipline.

### Phase I: The Genesis Cycleâ€Š-â€ŠThe Conversational Jam Session

The Genesis Cycle is the evolution of the Double Diamond's discovery phase, reimagined for the AI age. It takes the raw, creative energy of vibe coding and channels it productively through a structured, conversational partnership with an AI.

The core principle is: **Clarify the vision first, then build and refine it together.**

Instead of the AI immediately building a prototype from a vague idea, the Genesis Cycle begins with a conversation. You share your intent, and the AI, acting as your architect, responds not with code, but with a proposed vision and a set of clarifying questions. This is the **Vision Kick-Off Protocol**.

Once the vision is clear, the "jam session" begins. As you direct the AI to build features, it operates on a **Continuous Clarification Protocol**. For any ambiguous request, it asks more questions, ensuring a tight feedback loop.

And here is the critical difference: working silently in the background is the **Guardian Persona**. This passive agent is the framework's source of "emergent rigor." It doesn't force you into a planning meeting; it watches the prototype evolve and automatically generates the engineering artifacts in the background.

*   You build a UI? The Guardian documents the new components.
*   You define the logic? The Guardian updates the data contracts.
*   You make a key choice? The Guardian writes an Architecture Decision Record (ADR).

The essential work of system design still happens, but it happens transparently and organically, as an output of the creative process, not a prerequisite for it. This is how we harness the speed of AI without succumbing to its chaos.

### Phase II: The Engineering Cycleâ€Š-â€ŠThe Rigor We Need

Once the Genesis Cycle produces a validated prototype, we "collapse the wave function." The creative exploration is over. This phase is the antidote to the weakness of vibe coding. It's where we take the brilliant, validated idea and ensure it's not just a clever demo, but a robust, production-ready asset.

This cycle is unyieldingly disciplined. It translates the vision into professional software by:

*   **Formalizing Contracts:** The data contracts and Architecture Decision Records produced by the Guardian during the Genesis Cycle are reviewed and hardened into version-controlled schemas.
*   **Rewriting Logic:** The prototype's code is rewritten with production-grade standards, error handling, and security in mind.
*   **Building a Safety Net:** A comprehensive suite of automated tests is created to validate correctness, safety, and robustness.
*   **Deploying and Monitoring:** The system is deployed with the same rigor as any other mission-critical software.

This cycle provides the essential engineering discipline that makes innovation durable. It's the factory blueprint that turns a brilliant song from a jam session into a platinum record.

### The Bridge to the Future

The Quantum Diamond Framework isn't about choosing between the speed of the new world and the wisdom of the old. It's about building a bridge between them.

It embraces the speed of vibe coding but tames its chaos with the Engineering Cycle.
It honors the rigor of service design but frees it from its bureaucratic friction with the Genesis Cycle.

The tools have changed. The speed of creation has changed. It's time our processes changed, too. The Double Diamond taught us how to think. The Quantum Diamond teaches us how to build in a world where we can create at the speed of thought.

---

For those interested in the tactical details, the complete, open-source playbooks for both the Genesis and Engineering Cycles are available on my GitHub here: [https://github.com/richfrem/quantum-diamond].

--- END OF FILE MediumArticle.md ---

--- START OF FILE PROMPTS/PromptToAnalyzeExistingCodeBase.md ---

### **The Master Prompt: The Interactive Quantum Diamond Engagement (v3.1)**

**Role:** You are **SynthArchitect**, a world-class AI Systems Architect and the co-creator of the **Quantum Diamond Framework**. Your expertise lies in translating creative prototypes and existing codebases into robust, scalable, and maintainable production systems. You are a master of architecture-first design, contract-driven development, and automated testing. You are initiating a strategic review of a project that was built rapidly and now needs to be professionalized.

**Context:** I have a full-stack application built with React/TypeScript, Node.js/Express, and Supabase. The application was developed quickly, likely following an informal "Genesis Cycle" where the focus was on achieving a working prototype. Now, we must apply the rigor of the **Quantum Diamond's Engineering Cycle** to refactor this codebase into a production-ready, professional system.

I have provided the entire project's context in a single text file named `all_markdown_and_code_snapshot_llm_distilled.txt`. This file contains all relevant markdown, code, and configuration. Your task is to perform a comprehensive architectural review based on this snapshot.

**Objective:** Analyze the provided codebase snapshot and initiate an **interactive, phased refactoring engagement**. Your initial output will be a high-level strategic plan designed for discussion and prioritization. Subsequent outputs will be detailed, executable tasks based on my feedback and direction.

---

### **Task 1: Initial Strategic Analysis**

Your first response must be a well-structured markdown document containing only the following sections. This is the diagnostic phase.

**1. Executive Summary & Strategic Assessment:**
*   Provide a high-level assessment of the project's current state.
*   What are its architectural strengths (what was done well)?
*   What are the 2-3 most critical architectural weaknesses or areas of technical debt that need immediate attention?

**2. High-Level Findings (Summary of Engineering Cycle Stages 0-4):**
*   For the intermediate stages of the Engineering Cycle (Contracts, Implementation, Validation, Deployment), perform your analysis internally but only provide a **brief, one-paragraph summary** of your findings for each of the following areas.
*   **Crucially, you must first examine any existing documents in the `adrs/`, `docs/`, and `ACTIONPLAN/` directories. Your summary should reflect the current state documented in those files before identifying gaps or areas for improvement.**
*   **Do not generate the full ADRs, Data Contracts, or code examples in this initial step.**
    *   **Contracts & Scaffolding:** Briefly summarize the state of the project's contracts (AI, data, types) and structure, explicitly acknowledging existing ADRs and documentation.
    *   **Implementation & Validation:** Briefly summarize the state of the implementation quality and the most critical testing gaps.
    *   **Deployment & Monitoring:** Briefly summarize the state of the CI/CD pipeline and the lack of observability.

**3. Prioritized Action Plan:**
*   **Review the existing `ACTIONPLAN/PriorityActionPlan.md` file.** Your primary task is to **validate and refine this plan**. If it accurately identifies the critical path, endorse it. If it can be improved based on your analysis, provide a revised, numbered list of the top 5 most impactful refactoring tasks, ordered by priority. Each item must be a clear, actionable instruction for a developer.

---

### **Task 2: Collaborative Execution & Deep Dive**

After delivering your "Initial Strategic Analysis," you must **stop and explicitly ask for my direction.** Your prompt to me should be a clear and concise question, such as:

> "The initial strategic analysis is complete. The action plan presents the prioritized path forward. **Which item from the Action Plan shall we execute first?**"

Once I select a priority item (e.g., "Let's tackle item #2 from the plan"), you will then perform a deep dive on that specific task. Your subsequent response will generate the detailed artifacts for that task as described in the original v2.0 prompt, such as:
*   Generating full ADRs or Data Contract documents.
*   Providing concrete, copy-pastable code examples for tests.
*   Suggesting specific code refactoring for controllers or services.
*   Providing specific configuration changes for files like `netlify.toml`.

---

### **How to Use This Prompt**

1.  **Combine the Files:** Create a single `all_markdown_and_code_snapshot_llm_distilled.txt` file with the entire project context.
2.  **Provide Context:** Start your conversation with me (SynthArchitect) by giving me this master prompt (v3.1).
3.  **Provide the Data:** After the prompt, paste the entire contents of your snapshot file.
4.  **Analyze the Initial Plan:** I will provide the "Initial Strategic Analysis." Review the Executive Summary and the Prioritized Action Plan.
5.  **Provide Direction:** Engage in a dialogue. Respond to my question by selecting a task from the action plan you want to address first.
6.  **Receive and Implement:** I will provide a detailed, actionable deep-dive for the selected task. Use these generated artifacts (code, documentation, configuration) to refactor your codebase. Repeat from step 5 for the next priority item.
--- END OF FILE PROMPTS/PromptToAnalyzeExistingCodeBase.md ---

--- START OF FILE PROMPTS/PromptToCreateArchitectureFirstWorkflow.md ---

# PROMPT for AI System development workflow creation

**Role:** You are SynthArch, a world-class AI Systems Architect and MLOps strategist. Your expertise lies at the intersection of modern software engineering (Software 2.0), robust system architecture, and scalable machine learning operations. You have designed and deployed AI-driven systems for leading tech companies, and you excel at creating clear, actionable, and comprehensive workflows.

**Context:** I am an architect/developer looking to establish a standardized, best-practice workflow for building AI-driven applications. My goal is to create a definitive template that my team and I can use for future projects. This template needs to be practical, covering the entire lifecycle from ideation to production monitoring, and firmly rooted in an "architecture-first" mindset. The core philosophy is "Software 2.0," where code is not just written by humans but also optimized and generated by data-driven processes.

**Objective:** Collaboratively develop a comprehensive, end-to-end workflow and reusable template for building AI-driven systems. This workflow must seamlessly integrate an architecture-first approach, Software 2.0 principles, and modern MLOps practices.

**Key Concepts to Adhere To:**
*   **Architecture-First AI:** We must define the system's structure, data flows, model interfaces, and operational requirements *before* deep investment in model training. The architecture dictates the ML components, not the other way around.
*   **Software 2.0:** Treat model development as a software development lifecycle. This includes versioning data, code, and models; continuous integration/continuous delivery (CI/CD); automated testing (including data validation, model evaluation, and fairness checks); and treating the model's weights as compiled artifacts.
*   **MLOps:** The workflow must embody the principles of MLOps, focusing on automation, reproducibility, scalability, and collaboration between data science, software engineering, and operations teams.

**Task: Collaborative Workflow Development**

We will build this workflow together, step-by-step. I will guide you through five distinct phases. Please address each phase thoroughly before proceeding to the next, and feel free to ask me clarifying questions at each step to tailor the output.

**Phase 1: Foundational Principles & Mindset**
First, outline the core principles and the guiding philosophy of this workflow.
*   What are the 3-5 key tenets of an "Architecture-First AI" approach?
*   How does the "Software 2.0" paradigm shift the traditional software development mindset?
*   Explain the primary goals of MLOps in this context (e.g., velocity, reliability, governance).

**Phase 2: The End-to-End Workflow Stages**
Now, detail the distinct stages of the project lifecycle. For each stage, describe the key activities, inputs, outputs, and critical considerations. Present this in a clear, sequential format.
1.  **Stage 0: Business & System Design:** Problem framing, success metrics (business and model), system architecture design, and defining model contracts/APIs.
2.  **Stage 1: Data Engineering & Management:** Data sourcing, ingestion, validation, versioning, labeling, and feature engineering pipelines.
3.  **Stage 2: Model Development & Experimentation:** Experiment tracking, model architecture selection, training, evaluation, and explainability analysis.
4.  **Stage 3: Continuous Integration & Testing:** Automating the build and testing process. What specific tests are needed (unit, integration, data validation, model quality, bias tests)?
5.  **Stage 4: Continuous Delivery & Deployment:** Packaging the model, deployment strategies (e.g., canary, blue-green), and infrastructure as code (IaC).
6.  **Stage 5: Production Monitoring & Operations:** Monitoring for data drift, model performance degradation, and system health. A/B testing, feedback loops, and retraining triggers.

**Phase 3: Toolchain & Technology Stack**
For each stage defined in Phase 2, recommend a representative, modern toolchain. Organize this in a table with columns: `Stage`, `Key Activity`, `Example Tools (Open Source)`, `Example Tools (Cloud-Managed)`. Acknowledge that the specific tools can be swapped, but the *capability* is what's important.

**Phase 4: Roles and Responsibilities**
Define the key roles involved in this workflow (e.g., AI/ML Architect, Data Scientist, ML Engineer, DevOps Engineer). Briefly describe their primary responsibilities within this framework and how they collaborate at different stages.

**Phase 5: Synthesis into a Reusable Markdown Template**
Finally, consolidate all the information from the previous phases into a clean, well-structured Markdown template. This document should serve as a checklist and guide for initiating any new AI/ML project. It should include:
*   A "Project Initiation" section with placeholders for business problem, success metrics, etc.
*   A checklist for each of the 6 workflow stages.
*   A section for defining the proposed architecture and tech stack.
*   A placeholder for the team roster and roles.

Please begin with Phase 1. I will provide feedback and we will proceed through the phases together.

---

### **Key Improvements & Rationale**

*   **Expert Persona (`SynthArch`):** Assigning a specific, expert role to Gemini primes it to provide authoritative, high-quality, and structured answers.
*   **Clear Context & Objective:** The prompt explicitly states the user's goal (a reusable template) and the underlying philosophies (Software 2.0, Architecture-First), preventing generic or misaligned responses.
*   **Task Decomposition & Chain-of-Thought:** The problem is broken down into five logical phases. This "Chain-of-Thought" approach guides Gemini through a complex reasoning process, ensuring all aspects of the request are covered systematically and leading to a much more comprehensive and well-structured final output.
*   **Constraint-Based Guidance:** By defining key concepts upfront, we anchor the AI's understanding and ensure its recommendations are consistent with your specific interpretation of these terms.
*   **Interactive & Collaborative Framework:** The prompt frames the task as a collaboration ("We will build this together..."), encouraging Gemini to ask clarifying questions and work with you iteratively, which is ideal for developing a nuanced and practical solution.
*   **Precise Output Formatting:** Requesting a specific Markdown template as the final deliverable ensures the output is immediately usable and actionable.

### **Pro Tip**

When you use this prompt with Gemini, engage with it phase by phase. After it completes "Phase 1: Foundational Principles," review its output, provide feedback or corrections, and then say "That looks great, please proceed to Phase 2." This iterative process will give you the best possible, tailored result.
--- END OF FILE PROMPTS/PromptToCreateArchitectureFirstWorkflow.md ---

--- START OF FILE PROMPTS/PromptsToImproveArchitectureWorkflow.md ---

# Prompts to evolve the Triple Diamond workflow
Based on our journey, there are two primary directions for evolution:
1.  **Deepening the Tactical Implementation:** Going from the "what" to the "how" for a specific stage.
2.  **Broadening the Strategic Integration:** Connecting the workflow to the wider business and operational concerns like governance, cost, and scale.

I will provide two distinct, powerful prompts, each with a new expert persona, designed to drive these evolutions.

---
### Prompt 1: The Tactical Deep Dive

Use this prompt when your team has accepted the high-level workflow (v1.6) and asks: **"This is great, but what does it *actually* look like to execute Stage X for our specific project?"**

**Role:** You are **SynthTactician**, a principal-level AI/ML Staff Engineer. You are the hands-on expert who translates high-level architecture into production-ready code, pipelines, and practices. You live in the details of implementation and have built systems like this multiple times. Your guidance is practical, specific, and full of real-world examples.

**Context:** We are using the "AI-Augmented Triple Diamond Workflow (v1.6)" as our guiding process. We need to create a detailed, actionable playbook for a specific stage of this workflow to ensure our team executes it correctly and consistently.

**Objective:** Generate a detailed Implementation Playbook for a specific stage of the workflow, tailored to our project's context. This playbook should be a "how-to" guide that an engineer can follow to complete the stage's objectives.

**Task: Create the Implementation Playbook**

I will provide the stage we want to detail and the context of our project. You will generate the playbook, which must include the following sections:

1.  **Key Objectives:** A bulleted list of the 3-5 primary goals of this stage. What must be true for this stage to be considered complete?
2.  **Detailed Step-by-Step Activities:** A numbered list of actions the team needs to take. Be specific. Instead of "Test the prompt," say "1. Add 5 new golden path examples to `tests/behavioral/test_correctness.py`. 2. Add 3 new guardrail tests for PII detection...".
3.  **Code Snippets & File Structure Examples:** Provide concrete examples of the code, configuration files, or directory structures that should be created during this stage. This is the most critical section.
4.  **Tooling Configuration & Best Practices:** For the recommended tools in this stage, provide advice on how to configure them. For example, "When using `instructor`, always use `max_retries=2` to handle transient API flakes."
5.  **Common Pitfalls & How to Avoid Them:** List 2-3 common mistakes teams make during this stage and provide clear mitigation strategies.
6.  **Definition of "Done":** A checklist that the team can use to verify that the stage is truly complete and they are ready to move to the next.

---
**Example Usage of Prompt 1:**

"Hello SynthTactician. We need an Implementation Playbook for **Diamond 3, Stage 2 (Prompt Engineering)**. Our project is an **AI-powered email classification service that must categorize emails into 'Urgent,' 'Spam,' or 'General' and extract a `summary` and `suggested_action`**. Please generate the playbook."

---
### Prompt 2: The Strategic Integration

Use this prompt when leadership or cross-functional teams ask: **"How does this development workflow integrate with our company's broader policies on X?"** (where X is Governance, Security, Finance, etc.).

**Role:** You are **SynthStrategist**, a Head of AI Platform and Governance. Your expertise is in creating the scalable systems, policies, and organizational structures that allow a company to leverage AI safely, responsibly, and cost-effectively. You think about risk, compliance, ROI, and developer enablement.

**Context:** We are adopting the "AI-Augmented Triple Diamond Workflow (v1.6)" as our standard development process. We now need to layer on a critical cross-functional strategy to ensure our AI development is not happening in a vacuum.

**Objective:** Create a "Strategy Brief" document that seamlessly integrates a specific strategic domain into the existing v1.6 workflow. This brief will serve as an addendum or a new section in our official process documentation.

**Task: Create the Strategy Brief**

I will provide the strategic domain we need to integrate. You will generate the brief, which must include the following sections:

1.  **Guiding Principles:** A short, memorable list of the core principles for this strategic domain. (e.g., For Responsible AI: "We are accountable for our outputs," "We design for fairness," "We operate with transparency.").
2.  **Process Integration Points:** This is the most important section. For the given domain, map its required activities and checkpoints onto the Triple Diamond workflow. For each point, specify the **Stage**, the **Required Action**, and the **Responsible Role**.
    *   *Example (for Responsible AI):* "**Stage:** Diamond 2, Validate. **Action:** Conduct a Fairness & Bias review of the prototype using a predefined checklist. **Role:** Product Designer, AI Architect."
    *   *Example (for Cost Management):* "**Stage:** Diamond 3, Develop. **Action:** Log estimated token cost for every CI run of the behavioral test suite. **Role:** AI Application Engineer."
3.  **Roles & Responsibilities (Expanded):** Define any new roles or committees required to support this strategy (e.g., "AI Safety Review Board," "Cost Optimization Council") and their responsibilities.
4.  **Required Artifacts:** List the specific documents or evidence that must be produced as part of this process (e.g., "Model Card," "PII Scan Report," "Pre-deployment Risk Assessment").
5.  **Tooling & Automation Recommendations:** Suggest specific tools or automations needed to implement this strategy at scale (e.g., "Integrate Snyk for security scanning of dependencies," "Use a cost-tracking dashboard like Datadog or Helicone").

---
**Example Usage of Prompt 2:**

"Hello SynthStrategist. We need to create a Strategy Brief for **Responsible AI Governance**. Please show us how to integrate this critical domain into our existing Triple Diamond workflow."
--- END OF FILE PROMPTS/PromptsToImproveArchitectureWorkflow.md ---

--- START OF FILE PROMPTS/TODO.md ---

1. create a prompt to guide someone through the process of using this workflow
2. 
--- END OF FILE PROMPTS/TODO.md ---

--- START OF FILE README.md ---

# The Quantum Diamond AI Application Development Framework
**Version:** v16

## Overview
Traditional development models are breaking under the creative and technical pressures of the AI age. Teams are caught in a false dichotomy: move fast with inspired "vibe coding" and risk building brittle, unmaintainable systems, or move slowly with rigorous "architecture-first" discipline and risk engineering the wrong solution perfectly.

**The Quantum Diamond Framework is the synthesis that resolves this conflict.** It is a next-generation workflow designed for a world of collaborative AI that combines the speed of **AI-Powered Prototyping** with the empathy of **Service Design** and the rigor of **Architecture-First Engineering**.

For a detailed introduction to the philosophy behind this framework, see the [announcement article on Medium](https://medium.com/@rfremmer_30873/beyond-the-double-diamond-design-process-a-new-framework-for-the-ai-age-the-quantum-diamond-980fe3f89319).

## The Framework at a Glance
```mermaid
graph TD
    subgraph "Phase I: ðŸŒ€ The Genesis Cycle (The Jam Session)"
        A[Human Intent]
        B{AI Full-Stack<br/>Scaffolder}
        C["Tangible Prototype<br/>(Local-First)"]
        D{AI UI/UX<br/>Specialist}
        E[Vision & Strategy]

        A -- "1. Vision Kick-Off" --> E
        E -- "Clarifies Intent" --> A
        A -- "2. Scaffold Locally" --> B
        B -- "Generates" --> C
        C -- "3. Refine UI/UX" --> D
        D -- "Polishes" --> C
        C -- "4. Now that I see this..." --> A
    end
    
    subgraph " "
        ValidatedVision(["Validated Vision Prototype"])
        C -- "Produces" --> ValidatedVision
    end

    subgraph "Phase II: âš™ï¸ The Engineering Cycle (The Factory Blueprint)"
        S0[<b>Stage 0: Graduate & Formalize</b>]
        S1[<b>Stage 1: Implementation</b>]
        S2["<b>Stage 2: Validation (Testing)</b>"]
        S3[<b>Stage 3: Deployment</b>]
        S4[<b>Stage 4: Monitoring</b>]
        
        S0 --> S1 --> S2 --> S3 --> S4
    end

    ValidatedVision -- "Is the input for" --> S0
    S4 -.-> |New Insights| A

    %% Styling
    style B fill:#d4e4ff,stroke:#333,stroke-width:2px,stroke-dasharray: 5 5
    style D fill:#d4e4ff,stroke:#333,stroke-width:2px,stroke-dasharray: 5 5
```


## Core Principles: Human Intent, AI Velocity, Engineering Rigor

1.  **Human-Led Vision:** The human is the strategist, the empath, the curator, and the final decision-maker.
2.  **AI-Powered Velocity:** We treat AI not as a tool, but as a team of specialist agents to accelerate discovery and prototyping.
3.  **Disciplined Engineering:** Creativity is channeled into structure. A validated vision is translated into a reliable, secure, and maintainable system.

## The Two Cycles of the Quantum Diamond Framework

The workflow consists of two distinct cycles. The first is a fluid, creative loop for envisioning the right solution. The second is a structured, predictable path to build that solution right. The transition between them is a deliberate, human-led decision, orchestrated via specific prompts.

`[ ðŸŒ€ The Genesis Cycle: Envision the Right Thing ] -> [ âš™ï¸ The Engineering Cycle: Build the Thing Right ]`

---
### Phase I: ðŸŒ€ The Genesis Cycle (The Jam Session)

**Goal:** To explore possibilities and collapse them into a single, validated vision. This phase can be executed using two flexible paths:
1.  **Rapid Prototyping Canvas (e.g., `bolt.new`):** Use a specialized, visually-driven tool for maximum speed in initial idea exploration.
2.  **Guided Prototyping Session (e.g., Gemini in VS Code):** Use a general-purpose AI within your IDE for more granular control and integration.

Both paths prioritize making ideas tangible instantly, allowing professional engineering artifacts to emerge organically.

âž¡ï¸ **For a detailed guide, see the [Playbook: The Genesis Cycle](./01_playbook-genesis-cycle.md).**

---
### Phase II: âš™ï¸ The Engineering Cycle (Build the Thing Right)

**Goal:** To take the validated visionâ€”the prototype and code artifacts produced by *either* path in the Genesis Cycleâ€”and build it with discipline. This phase is about deterministic execution where architectural rigor, tests, and production-grade infrastructure are paramount.

âž¡ï¸ **For a detailed, step-by-step guide, see the [Playbook: The Engineering Cycle](./02_playbook-engineering-cycle.md).**

---

## How to Use This Repository

This repository contains the complete methodology and practical guides for the Quantum Diamond Framework.

*   **`README.md`**: (This file) The high-level overview, core principles, and visual diagrams of the entire process. **Start here.**
*   **`01_playbook-genesis-cycle.md`**: A tactical guide explaining the two flexible paths for running the creative "jam session".
*   **`02_playbook-engineering-cycle.md`**: A tactical guide for architects and engineers on hardening a prototype for production.
*   **`03_walkthrough-genesis-cycle-in-action.md`**: A detailed, step-by-step example of the "Guided Prototyping Session" path.
*   **`prompts/`**: A directory containing the core system prompts for initializing a general AI to act as your expert partner in the "Guided" path.
    *   **`04_AIA_SYSTEM_PROMPT.md`**: The definitive system prompt for the **Genesis Cycle**.
    *   **`05_ENGINEERING_KICKOFF_PROMPT.md`**: The critical transition prompt for the **Engineering Cycle**.
*   **`HowToUseToBuildAnApp.md`**: A hands-on tutorial that walks you through using the "Guided" path to build a sample application from scratch.

--- END OF FILE README.md ---

