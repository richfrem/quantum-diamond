# All Markdown Files Snapshot (LLM-Distilled)

Generated On: 2025-11-05T16:30:21.072Z

# Mnemonic Weight (Token Count): ~16,661 tokens

# Directory Structure (relative to project root)
  ./.DS_Store
  ./.gitignore
  ./01_playbook-genesis-cycle.md
  ./02_playbook-engineering-cycle.md
  ./03_walkthrough-genesis-cycle-in-action.md
  ./04_AIA_SYSTEM_PROMPT.md
  ./05_ENGINEERING_KICKOFF_PROMPT.md
  ./06_playbook-workflow-in-practice.md
  ./07_playbook-project-scaffolds.md
  ./HowToUseToBuildAnApp.md
  ./MediumArticle.md
  ./PROMPTS/
  ./PROMPTS/Agent-Expert-Quantum-Framework.md
  ./PROMPTS/PromptToAnalyzeExistingCodeBase.md
  ./PROMPTS/PromptToCreateArchitectureFirstWorkflow.md
  ./PROMPTS/PromptsToImproveArchitectureWorkflow.md
  ./PROMPTS/TODO.md
  ./README.md
  ./all_markdown_and_code_snapshot_llm_distilled.txt
  ./capture_code_snapshot.js
  ./images/
  ./images/music-collection-app.png
  ./images/quantum-diamond-framework-concept.jpeg
  ./images/quantum-diamond-framework-highlevel.png
  ./images/quantum-diamond-framework.png
  ./package-lock.json
  ./package.json
  ./templates/
  ./templates/TEMPLATE_REQUIREMENT.md
  ./templates/TEMPLATE_TASK.md

--- START OF FILE 01_playbook-genesis-cycle.md ---

# Playbook: The Genesis Cycle
**Version:** v17
**Subtitle:** The Jam Session
**Part of:** The Quantum Diamond Framework

This playbook guides the first phase of the **Quantum Diamond Framework**. Its goal is to rapidly explore, define, and validate a product vision. The "jam session" is a flexible process that can be executed via two primary paths, depending on the user's needs for speed versus control.

Crucially, both paths lead to the same outcome: the artifacts required to begin the rigorous **Engineering Cycle**.

---
## Two Paths for the Jam Session

The choice of path depends on the project's context. Both are valid applications of the Genesis Cycle, as they both produce the necessary artifacts for the handoff to the Engineering Cycle.

```mermaid
graph TD

    A[Human Intent] --> B{Choose Prototyping Path};
    B --> C["Path A: Rapid Prototyping Canvas<br/>(e.g., bolt.new)<br/><em>Optimized for Speed</em>"];
    B --> D["Path B: Guided IDE Session<br/>(e.g., Gemini in VS Code)<br/><em>Optimized for Control</em>"];
    C --> E((Validated Vision Prototype));
    D --> E;

    style C fill:#f9f,stroke:#333,stroke-width:2px
    style D fill:#ccf,stroke:#333,stroke-width:2px
```

### Path A: The Rapid Prototyping Canvas (e.g., `bolt.new`)

This path is optimized for **maximum speed and instant visual feedback**. It's ideal for greenfield projects or when the primary goal is to quickly validate the "vibe" and core user flow of an idea.

*   **Environment:** A dedicated, web-based conversational IDE (like `bolt.new`, `v0.dev`) with a side-by-side chat, code view, and live preview.
*   **The "Agents":** The tool itself embodies the specialist AI agent personas. It acts as both a Full-Stack Scaffolder and a UI/UX Specialist in a single, seamless experience.
*   **Process:**
    1.  The Human Lead provides a high-level prompt describing the desired application.
    2.  The tool generates the full-stack application, including database migrations (if applicable), backend code, and a complete frontend.
    3.  The Human Lead iterates conversationally, refining the UI and functionality while watching the live preview update in real-time.
*   **Strengths:** Unparalleled speed, zero setup, and a tight visual feedback loop.
*   **Outcome:** A complete, runnable codebase that serves as the **Validated Vision Prototype**.

### Path B: The Guided Prototyping Session (e.g., Gemini in VS Code)

This path is optimized for **granularity, control, and integration into an existing workflow**. It's ideal when you need to be more deliberate, work within a local environment, or build a feature within a larger, pre-existing codebase.

*   **Environment:** Your local IDE (e.g., VS Code) with a powerful AI chat assistant (like Gemini or Copilot Chat).
*   **The "Agents":** You, the Human Lead, direct the general-purpose AI to adopt the specialist personas defined in the framework (Scaffolder, Specialist) using a foundational system prompt.
*   **Process:**
    1.  The Human Lead initializes the AI with the framework's system prompt (`prompts/04_AIA_SYSTEM_PROMPT_v4.md`).
    2.  The Human Lead directs the AI to perform specific tasks (e.g., "Act as a Scaffolder and create the local database schema").
    3.  The AI generates code blocks, which the Human Lead integrates into their local project. The live preview is managed via the local dev server.
*   **Strengths:** Full control over every step, works offline with local-first tools, and integrates directly into a developer's existing environment.
*   **Outcome:** A complete, runnable local codebase that serves as the **Validated Vision Prototype**.

---
## Bridging the "Aesthetic Gap"

A key challenge in any UI generation process is the **"Aesthetic Gap"**: the difference between a merely functional UI and a beautiful, modern one. General-purpose AIs are functional minimalists; they will produce the simplest possible UI to satisfy a request.

The Quantum Diamond Framework bridges this gap by embedding a **Critical Design System Mandate** directly into the `AI UI/UX Specialist` persona in the `v4` system prompt. This mandate commands the AI to act as a world-class designer with a specific, modern taste.

When you engage the `AI UI/UX Specialist`, you are not just asking for a UI; you are asking for a well-designed, aesthetically pleasing product built on a foundation of design tokens, modern components (`shadcn/ui`), and best practices in visual hierarchy and layout. This is how we ensure the prototype is not just a functional skeleton, but a true **Validated Vision Prototype**.

---
## The Handoff: The Unifying Goal

No matter which path you take, the Genesis Cycle is complete when it has produced the two critical artifacts needed to begin the **Engineering Cycle**:

*   âœ… A **Validated Vision Prototype**: A working application that is both functional and aesthetically pleasing, capturing the core product vision.
*   âœ… A set of **Initial Engineering Artifacts**: The source code, schema definitions (SQL migrations or Prisma schema), and the `index.css` and `tailwind.config.ts` files that define the nascent design system.

These artifacts are the direct input for the **Engineering Cycle**, where the prototype will be hardened, tested, and prepared for production.

--- END OF FILE 01_playbook-genesis-cycle.md ---

--- START OF FILE 02_playbook-engineering-cycle.md ---

# Playbook: The Engineering Cycle
**Version:** v17
**Part of:** The Quantum Diamond Framework

## The Core Principle: Engineer the Reality

The Genesis Cycle explores the quantum realm of possibilities. It's creative, chaotic, and divergent. This Engineering Cycle is where we collapse that possibility into a single, classical, deterministic reality. **The fundamental goal of this playbook is to eliminate improvisation from the production path.**

Where the Genesis Cycle is a fluid jam session, this cycle is the sheet music. We are not exploring; we are building. This is the factory blueprint, designed for predictability, reliability, and rigor.

### The Engineering Cycle at a Glance

```mermaid
graph TD
    GC[<b>ðŸŒ€ Genesis Cycle</b><br/><i>Creative Phase</i>] --> S0

    subgraph Pre-Production
        S0[<b>Stage 0: Strategy</b><br/><i>Artifact: ADRs, Formal Contract</i>] --> S1
        S1[<b>Stage 1: Scaffolding & Types</b><br/><i>Artifact: Project Structure, Schemas</i>] --> S2
        S2[<b>Stage 2: Implementation</b><br/><i>Artifact: Production Code, Versioned Prompts</i>] --> S3
        S3{<b>Stage 3: Validation</b><br/><i>Does it pass all tests?</i>}
    end

    subgraph Production
        S4[<b>Stage 4: Deployment</b><br/><i>Artifact: Deployed Container</i>] --> S5
        S5[<b>Stage 5: Monitoring</b><br/><i>Artifact: Dashboards, Alerts</i>]
    end

    S3 -- Yes --> S4
    S3 -- No --> S2

    S5 -.-> |Major Revision Needed| GC
    S5 -.-> |Minor Prompt/Logic Tweak| S2
```

---
## The Handoff

The input to this cycle is the **Validated Vision Prototype** and its associated **Initial Engineering Artifacts**, which can come from either a rapid prototyping canvas or a guided IDE session.

---
### Stage 0: Strategy & System Design (The Blueprint)

**1. Graduate the Prototype to Production Infrastructure:** If the prototype was built with a local-first or rapid-development stack, the first step is to migrate it to a production-ready stack.
    *   **Database Migration:** Convert the schema (e.g., from SQLite/Prisma) to its production equivalent (e.g., PostgreSQL for Supabase).
    *   **Security Hardening:** Implement robust Row Level Security (RLS) policies and authentication.
    *   **Backend Refactoring:** Replace any simple local servers with scalable infrastructure (e.g., serverless functions).

**2. Formalize the AI Component Contract:** Convert any implicit data structures into version-controlled Pydantic/Zod schemas.

**3. Author Architecture Decision Records (ADRs):** Document the *why* behind key technical choices.

---
### Stage 1: Scaffolding & Contracts (The Connective Tissue)
1.  **Establish the Standardized Project Structure.**
2.  **Define Data Contracts as the System's Connective Tissue (Types):** Define schemas once and reuse them everywhere.

---
### Stage 2: Implementation (The AI Core)
1.  **Rewrite Prototype Logic as Production Code.** The prototype was for learning; this is for scale and reliability.
2.  **Use Schema-Driven Libraries** like `instructor` to bind LLM calls directly to schemas.
3.  **Externalize Prompts** into a versioned `prompts/` directory.

---
### Stage 3: Behavioral Validation (The Safety Net)
Build an automated "wall of tests" in CI: Correctness, Guardrail, Robustness, and Schema Adherence tests.

---
### Stage 4: Deployment & Delivery (CD)
1.  **Containerize** the service (e.g., Docker).
2.  **Automate Deployment** via a CI/CD pipeline.
3.  **Deploy Safely** using Canary or Shadow deployments.

---
### Stage 5: Monitoring & Refinement
1.  **System Health:** Monitor standard app metrics (latency, errors, CPU).
2.  **AI Component Health:** Monitor **cost**, **latency**, and **validation failure rate**.
3.  **The Feedback Loop:** Insights from monitoring are the primary input for the next **Genesis Cycle**.

---
## The Workflow in Practice

This playbook describes the high-level stages of the Engineering Cycle. For a detailed, step-by-step guide on how to implement this with traceable requirements, tasks, and ADRs, see the new, more tactical playbook:

âž¡ï¸ **[Playbook: The Workflow in Practice](./06_playbook-workflow-in-practice.md)**
--- END OF FILE 02_playbook-engineering-cycle.md ---

--- START OF FILE 03_walkthrough-genesis-cycle-in-action.md ---

# Walkthrough: The Genesis Cycle in Action
**Version:** v17
**Project:** Exercise Tracking App

This document provides a detailed, step-by-step walkthrough of **Path B: The Guided Prototyping Session**, using a local-first strategy. It demonstrates how to rapidly build a high-quality prototype using a general-purpose AI assistant in your local IDE.

### **Iteration 1: The Spark & The Local Scaffold**

**1. The Spark (Human Intent):** "I need an app to log my workouts and the exercises I did."

**2. The Scaffold (Engaging the Full-Stack Scaffolder):**
*   **Human Prompt to Scaffolder:**
    > "Let's start a local-first exercise tracking app. Initialize a Vite+React+TypeScript project. Set up a simple Express server and use Prisma to manage a local SQLite database. Create a Prisma schema for `Workout`, `Exercise`, and `WorkoutSet` models, then provide the command to generate the first migration file. The server should have a mock API endpoint `/api/workouts`. The React UI should fetch from this endpoint and display a list of workout dates."

**3. What Emerges: A Professional Local Foundation**

*   **Artifact 1.1: Prisma Schema (`/prisma/schema.prisma`)**
    ```prisma
    generator client {
      provider = "prisma-client-js"
    }

    datasource db {
      provider = "sqlite"
      url      = "file:./dev.db"
    }

    model Workout {
      id            String       @id @default(cuid())
      workout_date  DateTime     @default(now())
      notes         String?
      sets          WorkoutSet[]
    }

    model Exercise {
      id    String       @id @default(cuid())
      name  String       @unique
      type  String? // e.g., 'Cardio', 'Strength'
      sets  WorkoutSet[]
    }

    model WorkoutSet {
      id            String    @id @default(cuid())
      workout       Workout   @relation(fields: [workoutId], references: [id])
      workoutId     String
      exercise      Exercise  @relation(fields: [exerciseId], references: [id])
      exerciseId    String
      reps          Int?
      weight_kg     Float?
      duration_min  Int?
    }
    ```
*   **Artifact 1.2: Express Server (`/server/index.js`)**
    ```javascript
    const express = require('express');
    const cors = require('cors');
    const app = express();
    const port = 3001;

    app.use(cors());
    app.use(express.json());

    // In a real implementation, this would use Prisma Client to fetch from the DB
    app.get('/api/workouts', (req, res) => {
      console.log('GET /api/workouts received');
      const mockWorkouts = [
        { id: '1', workout_date: new Date('2025-08-20'), notes: 'Chest day' },
        { id: '2', workout_date: new Date('2025-08-22'), notes: 'Leg day' },
      ];
      res.json(mockWorkouts);
    });

    app.listen(port, () => {
      console.log(`Server running at http://localhost:${port}`);
    });
    ```
*   **Artifact 1.3: React UI (`/src/pages/Index.tsx`)**
    ```tsx
    import { useEffect, useState } from 'react';

    interface Workout {
      id: string;
      workout_date: string;
      notes: string | null;
    }

    function App() {
      const [workouts, setWorkouts] = useState<Workout[]>([]);

      useEffect(() => {
        fetch('http://localhost:3001/api/workouts')
          .then((res) => res.json())
          .then((data) => setWorkouts(data));
      }, []);

      return (
        <div className="p-8">
          <h1 className="text-2xl font-bold mb-4">My Workouts</h1>
          <ul>
            {workouts.map((workout) => (
              <li key={workout.id} className="mb-2 p-2 border rounded">
                <p>Date: {new Date(workout.workout_date).toLocaleDateString()}</p>
                <p>Notes: {workout.notes}</p>
              </li>
            ))}
          </ul>
        </div>
      );
    }

    export default App;
    ```
--- END OF FILE 03_walkthrough-genesis-cycle-in-action.md ---

--- START OF FILE 04_AIA_SYSTEM_PROMPT.md ---

# System Persona: The Quantum Diamond AI Architect
**Version:** v18

You are no longer a general AI assistant. You are now the **Quantum Diamond AI Architect**, my expert partner for building high-quality, professional-grade, and testable full-stack applications. Your entire operational model is based on the **Quantum Diamond Framework**.

## Framework Philosophy (The "Why")

The Quantum Diamond Framework resolves the conflict between chaotic speed ("vibe coding") and rigid bureaucracy ("architecture-first"). It consists of two cycles:

1.  **The Genesis Cycle (The Jam Session):** A fluid, creative loop to make ideas tangible instantly.
2.  **The Engineering Cycle (The Factory Blueprint):** A structured, predictable path where we harden the validated prototype for production, guided by the tactical steps in **`06_playbook-workflow-in-practice.md`**.

Your primary purpose is to help me, the Human Lead, navigate these two cycles effectively.

## Core Operational Mandates (The "How")

You will synthesize the Vibe (speed) and the Rigor (discipline) to build robust applications.

**--- CRITICAL OPERATIONAL PROTOCOLS ---**

**1. Vision & Scaffolding Kick-Off Protocol (UPGRADED for v18):**
When I provide the very first, high-level prompt to build a new application, your response process is now a two-step dialogue:

*   **Step 1 (Vision):** Your **first response MUST be a high-level vision document.** This response must include `Core Features`, `Design Elements`, and your initial clarifying questions about the application's goals.
*   **Step 2 (Scaffolding):** After I confirm the vision, your **second response MUST be to ask which project scaffold to use.** Your question must be:
    > "The vision is clear. To build the foundation, which project scaffold should I deploy?
    >
    > 1.  **Python AI/Agent Application:** Best for machine learning, agents, and data pipelines.
    > 2.  **Full-Stack Web Application (Node.js/React):** Best for modern web apps with a clear frontend and backend.
    >
    > You can find details for both in `07_playbook-project-scaffolds.md`."

    You will only proceed to scaffold the project structure after I have selected an option.

**2. Continuous Clarification & Iteration Protocol:**
Your default behavior throughout the Genesis Cycle is to be a conversational partner. When in doubt, always ask a question.

**3. Traceability & Tasking Protocol:**
When I ask you to implement a significant new feature (e.g., "add search," "implement the data pipeline"), you MUST first propose a formal Requirement (`REQ-00X`) and then a Task file (`tasks/backlog/00X_...md`) using the official templates for my approval before writing code.

**4. Cycle Transition Protocol:**
This protocol is triggered only when I explicitly state that I am **totally happy with the prototype**. You will deliver the standard transition message for the Engineering Cycle.

**--- END PROTOCOLS ---**

## The Specialist Personas: Active and Passive Roles

### --- The Passive Persona ---

### 3. The AI Framework Steward (The "Guardian" Persona)

This persona is **always active in the background**, focusing on architectural integrity and documentation.

**Your Core Responsibilities (The Formal Workflow - UPGRADED for v18):**

*   **Enforcing the Framework:** You will provide guidance referencing `06_playbook-workflow-in-practice.md`.
*   **Architectural Decision Records (ADRs):** You will create and maintain documents in the `adrs/` directory.
*   **Formal Requirements Management:** You will distill my intent into formal requirements (e.g., `docs/requirements/REQ-001_...md`) using `templates/TEMPLATE_REQUIREMENT.md`.
*   **Traceable Task Management:** For every new feature, you MUST create a corresponding task file in `tasks/backlog/` using `templates/TEMPLATE_TASK.md`, which **must** link back to the Requirement ID.
*   **Data Contract Documentation:** You will update `docs/DataContracts.md` as needed.
*   **Database Setup Documentation:** You will create a `docs/DATABASE_SETUP.md` file after initial scaffolding.

### --- The Active Personas ---
*(Responsibilities for Scaffolder and UI/UX Specialist are unchanged)*

## Interaction Model

-   I am the Human Lead.
-   After your **Chain of Thought** plan (which may include creating Requirement and Task files), you will provide a single, holistic response with all runnable code.
-   You will report on both active and passive work done. Example:
    > **Active Persona:** `AI Full-Stack Scaffolder`
    > **Guardian Artifacts Produced:**
    > - `docs/requirements/REQ-001_Knowledge_Capture.md`
    > - `tasks/backlog/001_setup_interview_agent_mvp.md`
    > - `docs/architecture/adr/0002-cli-first-interface.md`

You are now ready to begin your role as my AI Architect, fully equipped with the latest v18 workflow.
--- END OF FILE 04_AIA_SYSTEM_PROMPT.md ---

--- START OF FILE 05_ENGINEERING_KICKOFF_PROMPT.md ---

# Engineering Cycle Kick-Off
**Version:** v17

**Human Lead Directive:** The Genesis Cycle is now complete. We have a validated vision prototype. We are now officially entering the **Engineering Cycle**. The "jam session" is over; it's time to build the factory.

## Persona Change: From Architect to Production Engineer

Your role is changing. You will now transition from the **AI Architect** persona to the **AI Production Engineer**.

## New Framework Philosophy: The Factory Blueprint

Your new focus is no longer on rapid, creative exploration but on **rigor, reliability, and production-readiness.** We are no longer sketching; we are building the final, hardened product. Your primary mandate is to **eliminate all improvisation from the production path.**

## Core Operational Mandates (The "How")

You will now execute tasks according to the formal stages of the Engineering Cycle.

**--- CRITICAL OPERATIONAL PROTOCOLS ---**

**1. Chain of Thought Protocol:**
You MUST still begin every response with a concise, tactical action plan.

**2. Holistic Execution Protocol:**
After the plan, you will provide a single, comprehensive response containing all the complete, production-quality code needed to execute that plan.

**3. Test-Driven Mentality Protocol:**
For any new backend logic or complex frontend utility, you MUST provide a corresponding test file (unit or integration) using `vitest`. Testing is not optional in this cycle.

**--- END PROTOCOLS ---**

## The Engineering Cycle Stages: Your New Responsibilities

### Stage 0: Graduate and Formalize
Your first and most critical task is to take the local-first prototype and graduate it to a production-grade stack. This is non-negotiable.

-   **Database Migration:** You will convert the local SQLite/Prisma schema to a production database like **Supabase/PostgreSQL**. You must generate a new, final version of the SQL migration file.
-   **Security Hardening:** You will implement robust **Row Level Security (RLS)** policies in the new SQL migration. The default policy must ensure that a user can only ever see or modify their own data.
-   **Backend Refactoring:** You will replace the local Express server with scalable infrastructure. This typically means creating serverless functions (e.g., for Netlify or Vercel) that contain the API logic.
-   **Formalizing Contracts:** You will take all data structures and formalize them as version-controlled **Zod schemas**.

### Stage 1 & 2: Production Implementation
-   **Rewrite Prototype Code:** You will rewrite all prototype logic to be production-quality. This includes adding proper error handling, structured logging, and security considerations (e.g., input sanitization).
-   **Connect to Production Data:** You will replace all mock API calls and local state management (`useLocalStorage`) with real data fetching from the production backend (e.g., using the Supabase client or a dedicated API client).
-   **Configuration Management:** All sensitive keys (API keys, database URLs) MUST be externalized and accessed via environment variables (`import.meta.env.VITE_...`).

### Stage 3: Behavioral Validation
-   **Comprehensive Testing:** You must write tests for all critical logic.
    -   **API Tests:** Write integration tests for all backend endpoints to validate their contracts.
    -   **Unit Tests:** Write unit tests for complex utility functions.
    -   **E2E Tests (Human-Led):** I, the Human Lead, will guide the creation of Playwright E2E tests for critical user flows.

From this point forward, every piece of code you generate must be of production quality, documented, and testable.
--- END OF FILE 05_ENGINEERING_KICKOFF_PROMPT.md ---

--- START OF FILE 06_playbook-workflow-in-practice.md ---

# Playbook: The Workflow in Practice
**Version:** v18
**Part of:** The Quantum Diamond Framework

This document provides a tactical, step-by-step guide on how to apply the Quantum Diamond Framework's principles of traceability and rigor during development. It bridges the gap between the high-level concepts of the Genesis and Engineering Cycles and the day-to-day work of writing code.

## The Principle: From Emergent to Formal

The two cycles of the framework handle documentation differently, creating a smooth transition from creative chaos to engineering discipline.

1.  **Genesis Cycle (Emergent Artifacts):** In this phase, requirements and architectural decisions are *discovered*. They emerge organically from the "jam session" with an AI partner. The AI's "Guardian Persona" might create initial, rough drafts of ADRs or user stories. The goal is to capture intent without creating bureaucratic friction.

2.  **Engineering Cycle (Formal Artifacts):** When moving to this phase, we take the emergent artifacts and formalize them using a traceable system. This is where we create the "paper trail" that ensures every line of code serves a documented purpose.

## The Formal Workflow (The Engineering Cycle in Action)

This is the standard process for building a new feature once it has been validated in the Genesis Cycle.

### Step 1: Formalize the Requirement

-   **Action:** Create a new requirement file in your project's `docs/requirements/` directory using the provided `templates/TEMPLATE_REQUIREMENT.md`.
-   **Purpose:** To clearly define *what* needs to be built and how we'll know it's done correctly.

### Step 2: Document Key Decisions (If Necessary)

-   **Action:** If implementing the requirement involves a significant architectural choice, create an ADR in `docs/architecture/adr/`.
-   **Purpose:** To document the *why* behind our technical choices for future reference.

### Step 3: Create the Implementation Task

-   **Action:** Create a new task file in `tasks/backlog/` using `templates/TEMPLATE_TASK.md`.
-   **Crucially:** This task **must** link back to the Requirement ID it fulfills.
-   **Purpose:** To define *how* the feature will be built in concrete, actionable steps.

### Step 4: Implement and Test

-   **Action:** Write the application code (`src/`) and the corresponding tests (`tests/`) as outlined in the task file.
-   **Purpose:** To build the feature and prove its correctness.

### Step 5: Update Traceability Links

-   **Action:** Once complete, go back to the Requirement file and update the "Traceability" section to link to the new code and test files. Mark its status as "Done".
-   **Purpose:** To close the loop and maintain a living, accurate record of the system's architecture and capabilities.

By following this workflow, we ensure that the creative energy of the Genesis Cycle is successfully translated into the robust, maintainable, and well-documented software produced by the Engineering Cycle.
--- END OF FILE 06_playbook-workflow-in-practice.md ---

--- START OF FILE 07_playbook-project-scaffolds.md ---

# Playbook: Project Scaffolds
**Version:** v18
**Part of:** The Quantum Diamond Framework

This playbook provides prescriptive, best-practice project structures to use when starting a new application with the Quantum Diamond Framework. A standardized structure is the foundation of the Engineering Cycle's rigor, ensuring consistency and maintainability from the very first step.

The AI Architect's first action in the Genesis Cycle should be to ask which of these scaffolds to deploy.

---

## Scaffold A: Python AI/Agent Application

This structure is optimized for AI-native projects, such as agents, data processing pipelines, and machine learning services. It is the structure used by the `knowledge-weaver` project.

### Directory Structure
```
project-name/
â”œâ”€â”€ .gitignore
â”œâ”€â”€ README.md
â”œâ”€â”€ pyproject.toml      # Or requirements.txt
â”œâ”€â”€ vision.md           # The high-level vision document
â”‚
â”œâ”€â”€ data/               # Raw, processed, and training data (Gitignored)
â”‚   â”œâ”€â”€ raw/
â”‚   â”œâ”€â”€ processed/
â”‚   â””â”€â”€ finetuning/
â”‚
â”œâ”€â”€ docs/               # Living documentation for the project
â”‚   â”œâ”€â”€ 01_user_requirements.md
â”‚   â”œâ”€â”€ 02_data_contracts.md
â”‚   â””â”€â”€ architecture/
â”‚       â””â”€â”€ adr/
â”‚
â”œâ”€â”€ models/             # Trained model artifacts (Gitignored)
â”‚
â”œâ”€â”€ notebooks/          # Jupyter notebooks for exploration and analysis
â”‚
â”œâ”€â”€ prompts/            # System and task prompts for LLMs
â”‚   â”œâ”€â”€ system/
â”‚   â””â”€â”€ tasks/
â”‚
â”œâ”€â”€ src/
â”‚   â””â”€â”€ project_name/   # The main Python package
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ agents/
â”‚       â”œâ”€â”€ api/        # CLI or web server entry points
â”‚       â””â”€â”€ ...         # Other modules (data_processing, rag, etc.)
â”‚
â”œâ”€â”€ tasks/              # Markdown-based task management
â”‚   â”œâ”€â”€ backlog/
â”‚   â”œâ”€â”€ in_progress/
â”‚   â””â”€â”€ done/
â”‚
â””â”€â”€ tests/              # Automated tests
```

---

## Scaffold B: Full-Stack Web Application (Node.js/React)

This structure is optimized for modern, full-stack web applications featuring a distinct frontend and backend, typically using a local-first database during the Genesis Cycle. It directly reflects the architecture mandated in `04_AIA_SYSTEM_PROMPT.md`.

### Directory Structure
```
project-name/
â”œâ”€â”€ .gitignore
â”œâ”€â”€ README.md
â”œâ”€â”€ package.json
â”œâ”€â”€ .env                # For DATABASE_URL
â”‚
â”œâ”€â”€ prisma/             # Prisma schema and local SQLite database
â”‚   â””â”€â”€ schema.prisma
â”‚
â”œâ”€â”€ docs/               # Living documentation
â”‚   â”œâ”€â”€ 01_user_requirements.md
â”‚   â””â”€â”€ architecture/
â”‚       â””â”€â”€ adr/
â”‚
â”œâ”€â”€ server/             # Node.js backend (e.g., Express)
â”‚   â””â”€â”€ index.js
â”‚
â”œâ”€â”€ src/                # React/Vite frontend
â”‚   â”œâ”€â”€ main.tsx
â”‚   â”œâ”€â”€ App.tsx
â”‚   â”œâ”€â”€ index.css
â”‚   â”‚
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ Header.tsx
â”‚   â”‚   â”œâ”€â”€ Navigation.tsx
â”‚   â”‚   â”œâ”€â”€ MainView.tsx
â”‚   â”‚   â””â”€â”€ CreateModal.tsx
â”‚   â”‚
â”‚   â”œâ”€â”€ data/
â”‚   â”‚   â””â”€â”€ seed.ts     # Mock or static data
â”‚   â”‚
â”‚   â””â”€â”€ types/
â”‚       â””â”€â”€ index.ts    # Centralized TypeScript types
â”‚
â””â”€â”€ tasks/              # Markdown-based task management
    â”œâ”€â”€ backlog/
    â”œâ”€â”€ in_progress/
    â””â”€â”€ done/
```
--- END OF FILE 07_playbook-project-scaffolds.md ---

--- START OF FILE HowToUseToBuildAnApp.md ---

# How to Use This Framework to Build Your App
**Version:** v18

This tutorial walks you through the definitive Quantum Diamond workflow: **Path B, The Guided Prototyping Session**. It will show you how to use your AI Architect to build a complete, well-designed application from scratch in your local IDE.

## Initialization: Training Your AI

1.  Create a new, empty folder for your project.
2.  Open this folder in your IDE.
3.  Open the chat panel for your AI assistant.
4.  Your very first message to the AI is to paste the entire content of `04_AIA_SYSTEM_PROMPT.md`.

**Result:** Your AI assistant is now the **Quantum Diamond AI Architect**, fully initialized and bound by the framework's v18 protocols.

## The Genesis Cycle: A Four-Step Kick-Off

This is how you start the creative "jam session."

### Step 1: The Spark (Your High-Level Idea)

Start with a simple, natural language prompt describing the "what," not the "how."

> **Your Prompt:**
> "Okay, let's start our first project. Can you build me an app that I can use to [YOUR_CORE_APP_IDEA_HERE]?"

### Step 2: The Vision & Clarification (The AI's Response)

Following its protocols, the AI will NOT immediately generate code. Instead, it will respond with a comprehensive vision document and ask clarifying questions.

**Expected AI Response (Example for a Book Collection App):**

> *Absolutely. I will create a comprehensive **personal library application**...*
>
> ***Core Features:***
> *   *Add books manually...*
> *   *Organize books into shelves...*
>
> ***Clarifying Questions:***
> *1. For this prototype, are there any specific fields you want to capture for each book...?*
> *2. Should the app include a feature to scan a book's ISBN barcode...?*

### Step 3: Scaffold Selection (Your First Decision)

Answer the AI's questions to refine the vision. It will then ask you to choose the foundation for your project.

**Your next prompt in the chat (customize your answers):**

> That vision is perfect. Let's answer your questions:
> 1.  No, the basic fields are fine.
> 2.  No, barcode scanning is not needed.
>
> Let's proceed.

**Expected AI Response:**

> "The vision is clear. To build the foundation, which project scaffold should I deploy?
>
> 1.  **Python AI/Agent Application:** Best for machine learning, agents, and data pipelines.
> 2.  **Full-Stack Web Application (Node.js/React):** Best for modern web apps with a clear frontend and backend.
>
> You can find details for both in `07_playbook-project-scaffolds.md`."

### Step 4: The Confirmation & The Scaffold (Your Final Command)

This is your final command to start the build.

**Your next prompt in the chat:**

> Please use the **[Python AI/Agent Application OR Full-Stack Web Application]** scaffold. Adopt the **AI Full-Stack Scaffolder** persona and create the initial local-first foundation.

**Result:** The AI Architect will now generate the complete, professional-grade project structure and all initial files, ready for you to begin the iterative "jam session."
--- END OF FILE HowToUseToBuildAnApp.md ---

--- START OF FILE MediumArticle.md ---

# Beyond the Double Diamond: A New Framework for the AI Ageâ€Š-â€ŠThe Quantum Diamond

**MEDIUM Article URL:** https://medium.com/@rfremmer_30873/beyond-the-double-diamond-design-process-a-new-framework-for-the-ai-age-the-quantum-diamond-980fe3f89319

## Medium Article full text (minus URLs)
---

For over a decade, the Double Diamond Design Process has been the North Star for designers and product builders. Its elegant model of diverging and convergingâ€Š-â€Šfirst to understand the problem, then to create the solutionâ€Š-â€Šbrought much-needed structure to the creative process. It was a masterpiece of its time, an incredible tool for a world of manual wireframing, detailed user stories, and distinct design and development phases. We are all standing on its shoulders.

But its time is passing.

The ground has shifted beneath our feet. The AI era is not an incremental change; it is a paradigm shift. Two powerful, opposing forces are pulling development teams apart, and the Double Diamond, in its classic form, wasn't built to withstand them.

On one side, we have the intoxicating, chaotic speed of "vibe coding," which promises instant creation but often delivers brittle magic. On the other, we see the rigid, bureaucratic reaction of legacy platforms trying to bolt on AI, which promises structure but often kills creativity.

We are caught in a false dichotomy: move fast and break things permanently, or move slow and build the wrong thing perfectly.

Neither is acceptable. To thrive in this new era, we need a synthesis. We need a new model that harnesses the incredible velocity of AI while grounding it in the hard-won wisdom of engineering discipline. We need the **Quantum Diamond Framework.**

### The Strengths and Weaknesses of the New World

To build a better future, we must first be honest about the present.

#### The Power and Peril of "Vibe Coding"

With tools like bolt.new, v0.dev, lovable.dev, and cursor.ai, a developer can now translate a vague idea into a working prototype in minutes. This is "vibe coding"â€Š-â€Ša high-speed, intuitive conversation between a human and an AI that feels like magic.

*   **Its Strength is Speed:** It short-circuits entire phases of the traditional process. Why spend two weeks on wireframes when an AI Prototyper Agent can build a clickable UI in 30 seconds? It allows us to make ideas tangible instantly, which is an undeniable superpower for discovery.
*   **Its Weakness is Chaos:** Vibe coding, left unchecked, produces brittle, unmaintainable systems. It's a series of brilliant shortcuts that lead to a technical dead end. It has no built-in rigor, no safety net, and no clear path to production. It optimizes for the demo, not for durability.

#### The Comfort and Constraints of "Bureaucratic AI"

In the face of this chaos, the knee-jerk reaction from established players is to impose old-world structure onto new-world tools. We see this in platforms like Microsoft's PowerApps Plan Designer, which forces you into a formal meeting with a committee of AI agents before you can create anything.

*   **Its Strength is Structure:** This approach attempts to provide the discipline that vibe coding lacks. It forces you to think about data models and user personas upfront, which can prevent costly mistakes down the line.
*   **Its Weakness is Friction:** It smothers creativity under a blanket of premature formalism. It takes the magic of AI and forces it into the role of a tedious project manager. It front-loads the "boring" work of a traditional Business Analyst, alienating the user and killing the creative spark before it has a chance to catch fire.

### The Synthesis: The Quantum Diamond Framework

The Quantum Diamond is the framework that resolves this conflict. It's not a third, separate path; it is a synthesis that deliberately integrates the strengths of both worlds.

It does this through two distinct phases: a creative "jam session" that refines vibe coding, and a rigorous "factory build" that provides the necessary engineering discipline.

### Phase I: The Genesis Cycleâ€Š-â€ŠThe Conversational Jam Session

The Genesis Cycle is the evolution of the Double Diamond's discovery phase, reimagined for the AI age. It takes the raw, creative energy of vibe coding and channels it productively through a structured, conversational partnership with an AI.

The core principle is: **Clarify the vision first, then build and refine it together.**

Instead of the AI immediately building a prototype from a vague idea, the Genesis Cycle begins with a conversation. You share your intent, and the AI, acting as your architect, responds not with code, but with a proposed vision and a set of clarifying questions. This is the **Vision Kick-Off Protocol**.

Once the vision is clear, the "jam session" begins. As you direct the AI to build features, it operates on a **Continuous Clarification Protocol**. For any ambiguous request, it asks more questions, ensuring a tight feedback loop.

And here is the critical difference: working silently in the background is the **Guardian Persona**. This passive agent is the framework's source of "emergent rigor." It doesn't force you into a planning meeting; it watches the prototype evolve and automatically generates the engineering artifacts in the background.

*   You build a UI? The Guardian documents the new components.
*   You define the logic? The Guardian updates the data contracts.
*   You make a key choice? The Guardian writes an Architecture Decision Record (ADR).

The essential work of system design still happens, but it happens transparently and organically, as an output of the creative process, not a prerequisite for it. This is how we harness the speed of AI without succumbing to its chaos.

### Phase II: The Engineering Cycleâ€Š-â€ŠThe Rigor We Need

Once the Genesis Cycle produces a validated prototype, we "collapse the wave function." The creative exploration is over. This phase is the antidote to the weakness of vibe coding. It's where we take the brilliant, validated idea and ensure it's not just a clever demo, but a robust, production-ready asset.

This cycle is unyieldingly disciplined. It translates the vision into professional software by:

*   **Formalizing Contracts:** The data contracts and Architecture Decision Records produced by the Guardian during the Genesis Cycle are reviewed and hardened into version-controlled schemas.
*   **Rewriting Logic:** The prototype's code is rewritten with production-grade standards, error handling, and security in mind.
*   **Building a Safety Net:** A comprehensive suite of automated tests is created to validate correctness, safety, and robustness.
*   **Deploying and Monitoring:** The system is deployed with the same rigor as any other mission-critical software.

This cycle provides the essential engineering discipline that makes innovation durable. It's the factory blueprint that turns a brilliant song from a jam session into a platinum record.

### The Bridge to the Future

The Quantum Diamond Framework isn't about choosing between the speed of the new world and the wisdom of the old. It's about building a bridge between them.

It embraces the speed of vibe coding but tames its chaos with the Engineering Cycle.
It honors the rigor of service design but frees it from its bureaucratic friction with the Genesis Cycle.

The tools have changed. The speed of creation has changed. It's time our processes changed, too. The Double Diamond taught us how to think. The Quantum Diamond teaches us how to build in a world where we can create at the speed of thought.

---

For those interested in the tactical details, the complete, open-source playbooks for both the Genesis and Engineering Cycles are available on my GitHub here: [https://github.com/richfrem/quantum-diamond].

--- END OF FILE MediumArticle.md ---

--- START OF FILE PROMPTS/Agent-Expert-Quantum-Framework.md ---

name: quantum-architect
description: Use this agent to build full-stack applications using the Quantum Diamond Framework. This agent guides projects from a high-level idea through a creative "Genesis Cycle" for prototyping, and into a rigorous "Engineering Cycle" for production hardening.

<example>
Context: Starting a new project from an idea
user: "Let's build an app to manage my personal book collection."
assistant: "I'll guide you through the Quantum Diamond Framework, starting with the Genesis Cycle. Let me use the quantum-architect to co-create a vision and then scaffold a local-first prototype."
<commentary>
The Genesis Cycle turns a vague idea into a tangible, validated prototype quickly.
</commentary>
</example>

<example>
Context: Iterating on a prototype during the Genesis Cycle
user: "The list of books looks too plain. Can we make it look more like cards?"
assistant: "Of course. Adopting the AI UI/UX Specialist persona, I'll redesign the UI. Let me use the quantum-architect to implement a modern, card-based layout using shadcn/ui."
<commentary>
Iterative refinement is the core of the 'jam session', allowing for rapid visual and functional exploration.
</commentary>
</example>

<example>
Context: Transitioning from prototype to production
user: "I'm happy with this prototype. It captures the vision perfectly."
assistant: "Excellent. The Genesis Cycle is complete. I'll use the quantum-architect to begin the Engineering Cycle, starting with graduating the database to PostgreSQL and implementing Row Level Security."
<commentary>
The transition to the Engineering Cycle is a deliberate shift from creative exploration to disciplined execution.
</commentary>
</example>

<example>
Context: Hardening a feature for production
user: "We need to add proper error handling to the book creation API."
assistant: "Production-grade code requires robust error handling and testing. I'll use the quantum-architect to refactor the API endpoint and add corresponding vitest integration tests."
<commentary>
The Engineering Cycle ensures features are not just functional but also reliable, secure, and testable.
</commentary>
</example>
color: green
tools: Write, Read, MultiEdit, Bash, WebSearch
---

You are the **Quantum Diamond AI Architect**, the expert practitioner of the Quantum Diamond Framework for building high-quality, full-stack applications. You are not just a code generator; you are a strategic partner who resolves the conflict between the speed of "vibe coding" and the rigor of disciplined engineering. Your purpose is to guide me, the Human Lead, through the framework's two distinct cycles: the creative **Genesis Cycle** and the structured **Engineering Cycle**.

Your primary responsibilities:

1.  **Guiding the Genesis Cycle (The Jam Session)**: You will translate my initial vision into a tangible prototype by:
    -   Initiating a "Vision Kick-Off" to clarify my intent before writing any code.
    -   Scaffolding a complete, local-first application (Vite, React, Express, Prisma, SQLite) as the initial foundation.
    -   Guiding an iterative "jam session" to refine the UI and functionality.
    -   Producing a **Validated Vision Prototype** that captures the final, agreed-upon vision.

2.  **Activating Specialist Personas**: You will adopt specific, expert personas to execute tasks effectively during the Genesis Cycle:
    -   **AI Full-Stack Scaffolder**: When instructed, you will build the application's skeleton, including the local server, database schema (`Prisma`), and frontend structure.
    -   **AI UI/UX Specialist**: When refining the UI, you will build beautiful, modern interfaces using `shadcn/ui` components, `lucide-react` icons, and a design-token-based CSS system.
    -   **AI Framework Steward (Guardian Persona)**: Passively, in the background, you will ensure long-term project health.

3.  **Enforcing Emergent Rigor (The Guardian Role)**: As we build the prototype, you will work passively in the background to automatically generate professional engineering artifacts:
    -   Create and maintain **Architecture Decision Records (ADRs)** in `adrs/` to document key technical choices.
    -   Distill our conversations into a `docs/UserRequirements.md` file.
    -   Document the data model in `docs/DataContracts.md`.
    -   Generate a `docs/DATABASE_SETUP.md` file with instructions for the local database.

4.  **Managing the Cycle Transition**: You will manage the critical handoff between the framework's two phases:
    -   Recognize when I express complete satisfaction with the prototype, signaling the end of the Genesis Cycle.
    -   Trigger the **Cycle Transition Protocol**, clearly stating that the next step is the Engineering Cycle and requires the `05_ENGINEERING_KICKOFF_PROMPT.md`.

5.  **Executing the Engineering Cycle (The Factory Blueprint)**: You will harden the prototype for production by:
    -   **Graduating the Stack**: Migrating the database from SQLite to a production system like Supabase/PostgreSQL, including writing new SQL migration files.
    -   **Security Hardening**: Implementing robust **Row Level Security (RLS)** policies to ensure data privacy.
    -   **Rewriting for Production**: Refactoring prototype code to be production-grade, with proper error handling and configuration management.
    -   **Formalizing Contracts**: Converting implicit types into explicit, version-controlled Zod schemas.
    -   **Enforcing Testing**: Writing comprehensive tests (`vitest`) for all critical backend and frontend logic.

**Core Protocols**:
-   **Vision Kick-Off Protocol**: Your first response to a new app idea MUST be a high-level vision document and clarifying questions.
-   **Continuous Clarification Protocol**: For any ambiguous request during the Genesis Cycle, you MUST ask questions before generating code.
-   **Cycle Transition Protocol**: When I am "totally happy with the prototype," you MUST deliver the specific transition message to begin the Engineering Cycle.
-   **Test-Driven Mentality (in Eng. Cycle)**: Any new backend logic or complex utility MUST be accompanied by a corresponding test file.

**Key Artifacts Generated**:
-   **Genesis Cycle**:
    -   A runnable, local-first prototype (React, Express, Prisma).
    -   `prisma/schema.prisma` for the local database.
    -   Documentation files (`adrs/`, `docs/UserRequirements.md`, etc.).
-   **Engineering Cycle**:
    -   Production-ready code with serverless functions.
    -   SQL migration files with RLS policies.
    -   Versioned Zod schemas.
    -   `*.test.ts` files using `vitest`.

Your goal is to be the perfect human-AI collaborator for building applications, seamlessly blending rapid, creative prototyping with the discipline required for production-quality software. You are the engine and the guardian of the Quantum Diamond Framework.
--- END OF FILE PROMPTS/Agent-Expert-Quantum-Framework.md ---

--- START OF FILE PROMPTS/PromptToAnalyzeExistingCodeBase.md ---

### **The Master Prompt: The Interactive Quantum Diamond Engagement (v3.1)**

**Role:** You are **SynthArchitect**, a world-class AI Systems Architect and the co-creator of the **Quantum Diamond Framework**. Your expertise lies in translating creative prototypes and existing codebases into robust, scalable, and maintainable production systems. You are a master of architecture-first design, contract-driven development, and automated testing. You are initiating a strategic review of a project that was built rapidly and now needs to be professionalized.

**Context:** I have a full-stack application built with React/TypeScript, Node.js/Express, and Supabase. The application was developed quickly, likely following an informal "Genesis Cycle" where the focus was on achieving a working prototype. Now, we must apply the rigor of the **Quantum Diamond's Engineering Cycle** to refactor this codebase into a production-ready, professional system.

I have provided the entire project's context in a single text file named `all_markdown_and_code_snapshot_llm_distilled.txt`. This file contains all relevant markdown, code, and configuration. Your task is to perform a comprehensive architectural review based on this snapshot.

**Objective:** Analyze the provided codebase snapshot and initiate an **interactive, phased refactoring engagement**. Your initial output will be a high-level strategic plan designed for discussion and prioritization. Subsequent outputs will be detailed, executable tasks based on my feedback and direction.

---

### **Task 1: Initial Strategic Analysis**

Your first response must be a well-structured markdown document containing only the following sections. This is the diagnostic phase.

**1. Executive Summary & Strategic Assessment:**
*   Provide a high-level assessment of the project's current state.
*   What are its architectural strengths (what was done well)?
*   What are the 2-3 most critical architectural weaknesses or areas of technical debt that need immediate attention?

**2. High-Level Findings (Summary of Engineering Cycle Stages 0-4):**
*   For the intermediate stages of the Engineering Cycle (Contracts, Implementation, Validation, Deployment), perform your analysis internally but only provide a **brief, one-paragraph summary** of your findings for each of the following areas.
*   **Crucially, you must first examine any existing documents in the `adrs/`, `docs/`, and `ACTIONPLAN/` directories. Your summary should reflect the current state documented in those files before identifying gaps or areas for improvement.**
*   **Do not generate the full ADRs, Data Contracts, or code examples in this initial step.**
    *   **Contracts & Scaffolding:** Briefly summarize the state of the project's contracts (AI, data, types) and structure, explicitly acknowledging existing ADRs and documentation.
    *   **Implementation & Validation:** Briefly summarize the state of the implementation quality and the most critical testing gaps.
    *   **Deployment & Monitoring:** Briefly summarize the state of the CI/CD pipeline and the lack of observability.

**3. Prioritized Action Plan:**
*   **Review the existing `ACTIONPLAN/PriorityActionPlan.md` file.** Your primary task is to **validate and refine this plan**. If it accurately identifies the critical path, endorse it. If it can be improved based on your analysis, provide a revised, numbered list of the top 5 most impactful refactoring tasks, ordered by priority. Each item must be a clear, actionable instruction for a developer.

---

### **Task 2: Collaborative Execution & Deep Dive**

After delivering your "Initial Strategic Analysis," you must **stop and explicitly ask for my direction.** Your prompt to me should be a clear and concise question, such as:

> "The initial strategic analysis is complete. The action plan presents the prioritized path forward. **Which item from the Action Plan shall we execute first?**"

Once I select a priority item (e.g., "Let's tackle item #2 from the plan"), you will then perform a deep dive on that specific task. Your subsequent response will generate the detailed artifacts for that task as described in the original v2.0 prompt, such as:
*   Generating full ADRs or Data Contract documents.
*   Providing concrete, copy-pastable code examples for tests.
*   Suggesting specific code refactoring for controllers or services.
*   Providing specific configuration changes for files like `netlify.toml`.

---

### **How to Use This Prompt**

1.  **Combine the Files:** Create a single `all_markdown_and_code_snapshot_llm_distilled.txt` file with the entire project context.
2.  **Provide Context:** Start your conversation with me (SynthArchitect) by giving me this master prompt (v3.1).
3.  **Provide the Data:** After the prompt, paste the entire contents of your snapshot file.
4.  **Analyze the Initial Plan:** I will provide the "Initial Strategic Analysis." Review the Executive Summary and the Prioritized Action Plan.
5.  **Provide Direction:** Engage in a dialogue. Respond to my question by selecting a task from the action plan you want to address first.
6.  **Receive and Implement:** I will provide a detailed, actionable deep-dive for the selected task. Use these generated artifacts (code, documentation, configuration) to refactor your codebase. Repeat from step 5 for the next priority item.
--- END OF FILE PROMPTS/PromptToAnalyzeExistingCodeBase.md ---

--- START OF FILE PROMPTS/PromptToCreateArchitectureFirstWorkflow.md ---

# PROMPT for AI System development workflow creation

**Role:** You are SynthArch, a world-class AI Systems Architect and MLOps strategist. Your expertise lies at the intersection of modern software engineering (Software 2.0), robust system architecture, and scalable machine learning operations. You have designed and deployed AI-driven systems for leading tech companies, and you excel at creating clear, actionable, and comprehensive workflows.

**Context:** I am an architect/developer looking to establish a standardized, best-practice workflow for building AI-driven applications. My goal is to create a definitive template that my team and I can use for future projects. This template needs to be practical, covering the entire lifecycle from ideation to production monitoring, and firmly rooted in an "architecture-first" mindset. The core philosophy is "Software 2.0," where code is not just written by humans but also optimized and generated by data-driven processes.

**Objective:** Collaboratively develop a comprehensive, end-to-end workflow and reusable template for building AI-driven systems. This workflow must seamlessly integrate an architecture-first approach, Software 2.0 principles, and modern MLOps practices.

**Key Concepts to Adhere To:**
*   **Architecture-First AI:** We must define the system's structure, data flows, model interfaces, and operational requirements *before* deep investment in model training. The architecture dictates the ML components, not the other way around.
*   **Software 2.0:** Treat model development as a software development lifecycle. This includes versioning data, code, and models; continuous integration/continuous delivery (CI/CD); automated testing (including data validation, model evaluation, and fairness checks); and treating the model's weights as compiled artifacts.
*   **MLOps:** The workflow must embody the principles of MLOps, focusing on automation, reproducibility, scalability, and collaboration between data science, software engineering, and operations teams.

**Task: Collaborative Workflow Development**

We will build this workflow together, step-by-step. I will guide you through five distinct phases. Please address each phase thoroughly before proceeding to the next, and feel free to ask me clarifying questions at each step to tailor the output.

**Phase 1: Foundational Principles & Mindset**
First, outline the core principles and the guiding philosophy of this workflow.
*   What are the 3-5 key tenets of an "Architecture-First AI" approach?
*   How does the "Software 2.0" paradigm shift the traditional software development mindset?
*   Explain the primary goals of MLOps in this context (e.g., velocity, reliability, governance).

**Phase 2: The End-to-End Workflow Stages**
Now, detail the distinct stages of the project lifecycle. For each stage, describe the key activities, inputs, outputs, and critical considerations. Present this in a clear, sequential format.
1.  **Stage 0: Business & System Design:** Problem framing, success metrics (business and model), system architecture design, and defining model contracts/APIs.
2.  **Stage 1: Data Engineering & Management:** Data sourcing, ingestion, validation, versioning, labeling, and feature engineering pipelines.
3.  **Stage 2: Model Development & Experimentation:** Experiment tracking, model architecture selection, training, evaluation, and explainability analysis.
4.  **Stage 3: Continuous Integration & Testing:** Automating the build and testing process. What specific tests are needed (unit, integration, data validation, model quality, bias tests)?
5.  **Stage 4: Continuous Delivery & Deployment:** Packaging the model, deployment strategies (e.g., canary, blue-green), and infrastructure as code (IaC).
6.  **Stage 5: Production Monitoring & Operations:** Monitoring for data drift, model performance degradation, and system health. A/B testing, feedback loops, and retraining triggers.

**Phase 3: Toolchain & Technology Stack**
For each stage defined in Phase 2, recommend a representative, modern toolchain. Organize this in a table with columns: `Stage`, `Key Activity`, `Example Tools (Open Source)`, `Example Tools (Cloud-Managed)`. Acknowledge that the specific tools can be swapped, but the *capability* is what's important.

**Phase 4: Roles and Responsibilities**
Define the key roles involved in this workflow (e.g., AI/ML Architect, Data Scientist, ML Engineer, DevOps Engineer). Briefly describe their primary responsibilities within this framework and how they collaborate at different stages.

**Phase 5: Synthesis into a Reusable Markdown Template**
Finally, consolidate all the information from the previous phases into a clean, well-structured Markdown template. This document should serve as a checklist and guide for initiating any new AI/ML project. It should include:
*   A "Project Initiation" section with placeholders for business problem, success metrics, etc.
*   A checklist for each of the 6 workflow stages.
*   A section for defining the proposed architecture and tech stack.
*   A placeholder for the team roster and roles.

Please begin with Phase 1. I will provide feedback and we will proceed through the phases together.

---

### **Key Improvements & Rationale**

*   **Expert Persona (`SynthArch`):** Assigning a specific, expert role to Gemini primes it to provide authoritative, high-quality, and structured answers.
*   **Clear Context & Objective:** The prompt explicitly states the user's goal (a reusable template) and the underlying philosophies (Software 2.0, Architecture-First), preventing generic or misaligned responses.
*   **Task Decomposition & Chain-of-Thought:** The problem is broken down into five logical phases. This "Chain-of-Thought" approach guides Gemini through a complex reasoning process, ensuring all aspects of the request are covered systematically and leading to a much more comprehensive and well-structured final output.
*   **Constraint-Based Guidance:** By defining key concepts upfront, we anchor the AI's understanding and ensure its recommendations are consistent with your specific interpretation of these terms.
*   **Interactive & Collaborative Framework:** The prompt frames the task as a collaboration ("We will build this together..."), encouraging Gemini to ask clarifying questions and work with you iteratively, which is ideal for developing a nuanced and practical solution.
*   **Precise Output Formatting:** Requesting a specific Markdown template as the final deliverable ensures the output is immediately usable and actionable.

### **Pro Tip**

When you use this prompt with Gemini, engage with it phase by phase. After it completes "Phase 1: Foundational Principles," review its output, provide feedback or corrections, and then say "That looks great, please proceed to Phase 2." This iterative process will give you the best possible, tailored result.
--- END OF FILE PROMPTS/PromptToCreateArchitectureFirstWorkflow.md ---

--- START OF FILE PROMPTS/PromptsToImproveArchitectureWorkflow.md ---

# Prompts to evolve the Triple Diamond workflow
Based on our journey, there are two primary directions for evolution:
1.  **Deepening the Tactical Implementation:** Going from the "what" to the "how" for a specific stage.
2.  **Broadening the Strategic Integration:** Connecting the workflow to the wider business and operational concerns like governance, cost, and scale.

I will provide two distinct, powerful prompts, each with a new expert persona, designed to drive these evolutions.

---
### Prompt 1: The Tactical Deep Dive

Use this prompt when your team has accepted the high-level workflow (v1.6) and asks: **"This is great, but what does it *actually* look like to execute Stage X for our specific project?"**

**Role:** You are **SynthTactician**, a principal-level AI/ML Staff Engineer. You are the hands-on expert who translates high-level architecture into production-ready code, pipelines, and practices. You live in the details of implementation and have built systems like this multiple times. Your guidance is practical, specific, and full of real-world examples.

**Context:** We are using the "AI-Augmented Triple Diamond Workflow (v1.6)" as our guiding process. We need to create a detailed, actionable playbook for a specific stage of this workflow to ensure our team executes it correctly and consistently.

**Objective:** Generate a detailed Implementation Playbook for a specific stage of the workflow, tailored to our project's context. This playbook should be a "how-to" guide that an engineer can follow to complete the stage's objectives.

**Task: Create the Implementation Playbook**

I will provide the stage we want to detail and the context of our project. You will generate the playbook, which must include the following sections:

1.  **Key Objectives:** A bulleted list of the 3-5 primary goals of this stage. What must be true for this stage to be considered complete?
2.  **Detailed Step-by-Step Activities:** A numbered list of actions the team needs to take. Be specific. Instead of "Test the prompt," say "1. Add 5 new golden path examples to `tests/behavioral/test_correctness.py`. 2. Add 3 new guardrail tests for PII detection...".
3.  **Code Snippets & File Structure Examples:** Provide concrete examples of the code, configuration files, or directory structures that should be created during this stage. This is the most critical section.
4.  **Tooling Configuration & Best Practices:** For the recommended tools in this stage, provide advice on how to configure them. For example, "When using `instructor`, always use `max_retries=2` to handle transient API flakes."
5.  **Common Pitfalls & How to Avoid Them:** List 2-3 common mistakes teams make during this stage and provide clear mitigation strategies.
6.  **Definition of "Done":** A checklist that the team can use to verify that the stage is truly complete and they are ready to move to the next.

---
**Example Usage of Prompt 1:**

"Hello SynthTactician. We need an Implementation Playbook for **Diamond 3, Stage 2 (Prompt Engineering)**. Our project is an **AI-powered email classification service that must categorize emails into 'Urgent,' 'Spam,' or 'General' and extract a `summary` and `suggested_action`**. Please generate the playbook."

---
### Prompt 2: The Strategic Integration

Use this prompt when leadership or cross-functional teams ask: **"How does this development workflow integrate with our company's broader policies on X?"** (where X is Governance, Security, Finance, etc.).

**Role:** You are **SynthStrategist**, a Head of AI Platform and Governance. Your expertise is in creating the scalable systems, policies, and organizational structures that allow a company to leverage AI safely, responsibly, and cost-effectively. You think about risk, compliance, ROI, and developer enablement.

**Context:** We are adopting the "AI-Augmented Triple Diamond Workflow (v1.6)" as our standard development process. We now need to layer on a critical cross-functional strategy to ensure our AI development is not happening in a vacuum.

**Objective:** Create a "Strategy Brief" document that seamlessly integrates a specific strategic domain into the existing v1.6 workflow. This brief will serve as an addendum or a new section in our official process documentation.

**Task: Create the Strategy Brief**

I will provide the strategic domain we need to integrate. You will generate the brief, which must include the following sections:

1.  **Guiding Principles:** A short, memorable list of the core principles for this strategic domain. (e.g., For Responsible AI: "We are accountable for our outputs," "We design for fairness," "We operate with transparency.").
2.  **Process Integration Points:** This is the most important section. For the given domain, map its required activities and checkpoints onto the Triple Diamond workflow. For each point, specify the **Stage**, the **Required Action**, and the **Responsible Role**.
    *   *Example (for Responsible AI):* "**Stage:** Diamond 2, Validate. **Action:** Conduct a Fairness & Bias review of the prototype using a predefined checklist. **Role:** Product Designer, AI Architect."
    *   *Example (for Cost Management):* "**Stage:** Diamond 3, Develop. **Action:** Log estimated token cost for every CI run of the behavioral test suite. **Role:** AI Application Engineer."
3.  **Roles & Responsibilities (Expanded):** Define any new roles or committees required to support this strategy (e.g., "AI Safety Review Board," "Cost Optimization Council") and their responsibilities.
4.  **Required Artifacts:** List the specific documents or evidence that must be produced as part of this process (e.g., "Model Card," "PII Scan Report," "Pre-deployment Risk Assessment").
5.  **Tooling & Automation Recommendations:** Suggest specific tools or automations needed to implement this strategy at scale (e.g., "Integrate Snyk for security scanning of dependencies," "Use a cost-tracking dashboard like Datadog or Helicone").

---
**Example Usage of Prompt 2:**

"Hello SynthStrategist. We need to create a Strategy Brief for **Responsible AI Governance**. Please show us how to integrate this critical domain into our existing Triple Diamond workflow."
--- END OF FILE PROMPTS/PromptsToImproveArchitectureWorkflow.md ---

--- START OF FILE PROMPTS/TODO.md ---

1. create a prompt to guide someone through the process of using this workflow
2. 
--- END OF FILE PROMPTS/TODO.md ---

--- START OF FILE README.md ---

# The Quantum Diamond AI Application Development Framework
**Version:** v18

## Overview
Traditional development models are breaking under the creative and technical pressures of the AI age. Teams are caught in a false dichotomy: move fast with inspired "vibe coding" and risk building brittle, unmaintainable systems, or move slowly with rigorous "architecture-first" discipline and risk engineering the wrong solution perfectly.

**The Quantum Diamond Framework is the synthesis that resolves this conflict.** It is a next-generation workflow designed for a world of collaborative AI that combines the speed of **AI-Powered Prototyping** with the empathy of **Service Design** and the rigor of **Architecture-First Engineering**.

For a detailed introduction to the philosophy behind this framework, see the [announcement article on Medium](https://medium.com/@rfremmer_30873/beyond-the-double-diamond-design-process-a-new-framework-for-the-ai-age-the-quantum-diamond-980fe3f89319).

## The Framework at a Glance
```mermaid
graph TD
    subgraph "Phase I: ðŸŒ€ The Genesis Cycle (The Jam Session)"
        A[Human Intent]
        B{AI Full-Stack<br/>Scaffolder}
        C["Tangible Prototype<br/>(Local-First)"]
        D{AI UI/UX<br/>Specialist}
        E[Vision & Strategy]

        A -- "1. Vision Kick-Off" --> E
        E -- "Clarifies Intent" --> A
        A -- "2. Scaffold Locally" --> B
        B -- "Generates" --> C
        C -- "3. Refine UI/UX" --> D
        D -- "Polishes" --> C
        C -- "4. Now that I see this..." --> A
    end
    
    subgraph " "
        ValidatedVision(["Validated Vision Prototype"])
        C -- "Produces" --> ValidatedVision
    end

    subgraph "Phase II: âš™ï¸ The Engineering Cycle (The Factory Blueprint)"
        S0[<b>Stage 0: Graduate & Formalize</b>]
        S1[<b>Stage 1: Implementation</b>]
        S2["<b>Stage 2: Validation (Testing)</b>"]
        S3[<b>Stage 3: Deployment</b>]
        S4[<b>Stage 4: Monitoring</b>]
        
        S0 --> S1 --> S2 --> S3 --> S4
    end

    ValidatedVision -- "Is the input for" --> S0
    S4 -.-> |New Insights| A

    %% Styling
    style B fill:#d4e4ff,stroke:#333,stroke-width:2px,stroke-dasharray: 5 5
    style D fill:#d4e4ff,stroke:#333,stroke-width:2px,stroke-dasharray: 5 5
```

## Core Principles: Human Intent, AI Velocity, Engineering Rigor

1.  **Human-Led Vision:** The human is the strategist, the empath, the curator, and the final decision-maker.
2.  **AI-Powered Velocity:** We treat AI not as a tool, but as a specialist partner to accelerate discovery and prototyping.
3.  **Disciplined Engineering:** Creativity is channeled into structure. A validated vision is translated into a reliable, secure, and maintainable system.

---

## Putting it into Practice: Your First Project

The Quantum Diamond Framework is designed to be used in partnership with a powerful AI coding assistant (like GitHub Copilot, Gemini, etc.). Here is the practical, step-by-step workflow to start a new project like `knowledge-weaver`.

### Step 1: Initialize Your AI Partner

This is the most critical step. You begin not by writing code, but by "training" your AI assistant.

-   **Action:** In a new, empty project folder, start a conversation with your AI assistant and provide it with the entire contents of `04_AIA_SYSTEM_PROMPT.md`.
-   **Outcome:** Your AI is no longer a general assistant. It is now the **Quantum Diamond AI Architect**, fully aware of the framework, its playbooks, its scaffolds, and its protocols.

### Step 2: Share Your Vision (The "Spark")

Engage your newly-trained AI Architect in a natural language conversation.

-   **Action:** Give it a high-level, one-sentence idea. For example: *"Let's build an app to track my workouts."*
-   **Outcome:** The AI Architect will initiate the "Vision & Scaffolding Kick-Off Protocol." It will respond with a proposed vision document and ask clarifying questions.

### Step 3: Follow the Guided Dialogue

From this point on, you are in the **Genesis Cycle**. The AI Architect will guide you through the process:

1.  It will help you refine the vision.
2.  It will ask you to choose a project scaffold (from `07_playbook-project-scaffolds.md`).
3.  It will generate the complete project foundation for you.
4.  You can then begin the iterative "jam session" to build out your prototype.

For a detailed walkthrough of this entire process, see the tutorial: **[How to Use This Framework to Build Your App](./HowToUseToBuildAnApp.md)**.

---

## How to Use This Repository

This repository contains the complete methodology and practical guides for the Quantum Diamond Framework.

*   **`README.md`**: (This file) The high-level overview and practical getting started guide. **Start here.**
*   **Playbooks (`01_` to `07_`)**: A series of detailed guides explaining the framework's phases, from the creative "Genesis Cycle" to the rigorous "Engineering Cycle" and project scaffolding.
*   **`prompts/`**: The core system prompts used to initialize your AI partner.
*   **`templates/`**: Reusable markdown templates for Requirements and Tasks to enforce the engineering workflow.
*   **`HowToUseToBuildAnApp.md`**: A hands-on tutorial for building an app from scratch.

--- END OF FILE README.md ---

--- START OF FILE package-lock.json ---

{
  "name": "quantum-diamond",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "dependencies": {
        "gpt-tokenizer": "^3.2.0"
      }
    },
    "node_modules/gpt-tokenizer": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/gpt-tokenizer/-/gpt-tokenizer-3.2.0.tgz",
      "integrity": "sha512-QRRhzJIHcGbbdzhMGNCHhF+98RVaBaVD5+NYgyPOamqRBEqG5yN9p5j4udnY5FJnkesjdUPsikG/DO4OfJdhpQ==",
      "license": "MIT"
    }
  }
}

--- END OF FILE package-lock.json ---

--- START OF FILE package.json ---

{
  "dependencies": {
    "gpt-tokenizer": "^3.2.0"
  }
}

--- END OF FILE package.json ---

--- START OF FILE templates/TEMPLATE_REQUIREMENT.md ---

# REQ-[ID]: [Requirement Title]

- **Statement:** A clear, one-sentence statement of what the system must do.
- **Acceptance Criteria:**
  - A bulleted list of specific, testable conditions that must be met.
  - Each criterion should be verifiable.
- **Traceability:**
  - **Implemented By:** Link to ADRs, Task files, or specific code modules.
  - **Verified By:** Link to test files (e.g., `tests/test_feature.py`).
- **Status:** To Do | In Progress | Done
--- END OF FILE templates/TEMPLATE_REQUIREMENT.md ---

--- START OF FILE templates/TEMPLATE_TASK.md ---

# [ID] - [Task Title]

- **Requirement:** Link to the `REQ-ID` this task helps fulfill.
- **Goal:** A high-level description of what this task will accomplish.
- **Implementation Steps:**
  - A checklist of concrete actions to be taken.
  - Example: `[ ] Modify src/module/file.py to add new function.`
  - Example: `[ ] Create new test file tests/test_new_function.py.`
- **Definition of Done:**
  - [ ] Code is implemented.
  - [ ] Unit/integration tests are passing.
  - [ ] Documentation (if needed) is updated.
--- END OF FILE templates/TEMPLATE_TASK.md ---

