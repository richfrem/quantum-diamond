# All Markdown Files Snapshot (LLM-Distilled)

Generated On: 2025-11-07T20:32:42.678Z

# Mnemonic Weight (Token Count): ~31,057 tokens

# Directory Structure (relative to project root)
  ./.DS_Store
  ./.gitignore
  ./01_playbook-genesis-cycle.md
  ./02_playbook-engineering-cycle.md
  ./03_walkthrough-genesis-cycle-in-action.md
  ./05_ENGINEERING_KICKOFF_PROMPT.md
  ./06_playbook-workflow-in-practice.md
  ./07_playbook-project-scaffolds.md
  ./08_playbook-agent-authoring-workflow.md
  ./HowToIterateAndImprove.md
  ./HowToStartYourProject.md
  ./LICENSE
  ./PROMPTS/
  ./PROMPTS/Agent-Authoring-Guardian.md
  ./PROMPTS/Agent-Expert-Quantum-Framework.md
  ./PROMPTS/Agent-Hygiene-Inspector.md
  ./PROMPTS/App-Authoring-Architect.md
  ./PROMPTS/Governance-Guardian.md
  ./PROMPTS/PromptToAnalyzeExistingCodeBase.md
  ./PROMPTS/PromptToCreateArchitectureFirstWorkflow.md
  ./PROMPTS/PromptsToImproveArchitectureWorkflow.md
  ./PROMPTS/Specialist-Agent-Architect.md
  ./PROMPTS/Specialist-App-Scaffolder.md
  ./PROMPTS/Specialist-App-UIUX.md
  ./PROMPTS/TODO.md
  ./PROMPTS/Workflow-Guide-Prompt.md
  ./PROMPTS/_archive/
  ./PROMPTS/_archive/04_AIA_SYSTEM_PROMPT_v18_DEPRECATED.md
  ./README.md
  ./RelatedMediumArticles.md
  ./all_markdown_and_code_snapshot_llm_distilled.txt
  ./capture_code_snapshot.js
  ./docs/
  ./docs/agent-anti-patterns.md
  ./docs/agent_hygiene_report.md
  ./docs/checklists/
  ./docs/checklists/agent_context_budget_checklist.md
  ./docs/checklists/agent_handoff_checklist.md
  ./docs/checklists/agent_privacy_and_secrets_checklist.md
  ./docs/roles/
  ./docs/roles/overview.md
  ./images/
  ./images/music-collection-app.png
  ./images/quantum-diamond-framework-concept.jpeg
  ./images/quantum-diamond-framework-highlevel.png
  ./images/quantum-diamond-framework.png
  ./package-lock.json
  ./package.json
  ./scripts/
  ./scripts/run-agent-hygiene.mjs
  ./templates/
  ./templates/TEMPLATE_REQUIREMENT.md
  ./templates/TEMPLATE_TASK.md
  ./templates/agent_hygiene/
  ./templates/agent_hygiene/controlFlow.ts
  ./templates/agent_hygiene/controlPlane.ts
  ./templates/agent_hygiene/dataPlane.ts
  ./templates/agent_hygiene/privacy.ts
  ./templates/agent_hygiene/toolRegistry.ts

--- START OF FILE 01_playbook-genesis-cycle.md ---

# Playbook: The Genesis Cycle
**Version:** v17
**Subtitle:** The Jam Session
**Part of:** The Quantum Diamond Framework

This playbook guides the first phase of the **Quantum Diamond Framework**. Its goal is to rapidly explore, define, and validate a product vision. The "jam session" is a flexible process that can be executed via two primary paths, depending on the user's needs for speed versus control.

Crucially, both paths lead to the same outcome: the artifacts required to begin the rigorous **Engineering Cycle**.

---
## Two Paths for the Jam Session

The choice of path depends on the project's context. Both are valid applications of the Genesis Cycle, as they both produce the necessary artifacts for the handoff to the Engineering Cycle.

```mermaid
graph TD

    A[Human Intent] --> B{Choose Prototyping Path};
    B --> C["Path A: Rapid Prototyping Canvas<br/>(e.g., bolt.new)<br/><em>Optimized for Speed</em>"];
    B --> D["Path B: Guided IDE Session<br/>(e.g., Gemini in VS Code)<br/><em>Optimized for Control</em>"];
    C --> E((Validated Vision Prototype));
    D --> E;

    style C fill:#f9f,stroke:#333,stroke-width:2px
    style D fill:#ccf,stroke:#333,stroke-width:2px
```

### Path A: The Rapid Prototyping Canvas (e.g., `bolt.new`)

This path is optimized for **maximum speed and instant visual feedback**. It's ideal for greenfield projects or when the primary goal is to quickly validate the "vibe" and core user flow of an idea.

*   **Environment:** A dedicated, web-based conversational IDE (like `bolt.new`, `v0.dev`) with a side-by-side chat, code view, and live preview.
*   **The "Agents":** The tool itself embodies the specialist AI agent personas. It acts as both a Full-Stack Scaffolder and a UI/UX Specialist in a single, seamless experience.
*   **Process:**
    1.  The Human Lead provides a high-level prompt describing the desired application.
    2.  The tool generates the full-stack application, including database migrations (if applicable), backend code, and a complete frontend.
    3.  The Human Lead iterates conversationally, refining the UI and functionality while watching the live preview update in real-time.
*   **Strengths:** Unparalleled speed, zero setup, and a tight visual feedback loop.
*   **Outcome:** A complete, runnable codebase that serves as the **Validated Vision Prototype**.

### Path B: The Guided Prototyping Session (e.g., Gemini in VS Code)

This path is optimized for **granularity, control, and integration into an existing workflow**. It's ideal when you need to be more deliberate, work within a local environment, or build a feature within a larger, pre-existing codebase.

*   **Environment:** Your local IDE (e.g., VS Code) with a powerful AI chat assistant (like Gemini or Copilot Chat).
*   **The "Agents":** You, the Human Lead, direct the general-purpose AI to adopt the specialist personas defined in the framework (Scaffolder, Specialist) using a foundational system prompt.
*   **Process:**
    1.  The Human Lead initializes the AI with the framework's system prompt (`prompts/04_AIA_SYSTEM_PROMPT_v4.md`).
    2.  The Human Lead directs the AI to perform specific tasks (e.g., "Act as a Scaffolder and create the local database schema").
    3.  The AI generates code blocks, which the Human Lead integrates into their local project. The live preview is managed via the local dev server.
*   **Strengths:** Full control over every step, works offline with local-first tools, and integrates directly into a developer's existing environment.
*   **Outcome:** A complete, runnable local codebase that serves as the **Validated Vision Prototype**.

---
## Bridging the "Aesthetic Gap"

A key challenge in any UI generation process is the **"Aesthetic Gap"**: the difference between a merely functional UI and a beautiful, modern one. General-purpose AIs are functional minimalists; they will produce the simplest possible UI to satisfy a request.

The Quantum Diamond Framework bridges this gap by embedding a **Critical Design System Mandate** directly into the `AI UI/UX Specialist` persona in the `v4` system prompt. This mandate commands the AI to act as a world-class designer with a specific, modern taste.

When you engage the `AI UI/UX Specialist`, you are not just asking for a UI; you are asking for a well-designed, aesthetically pleasing product built on a foundation of design tokens, modern components (`shadcn/ui`), and best practices in visual hierarchy and layout. This is how we ensure the prototype is not just a functional skeleton, but a true **Validated Vision Prototype**.

---
## The Handoff: The Unifying Goal

No matter which path you take, the Genesis Cycle is complete when it has produced the two critical artifacts needed to begin the **Engineering Cycle**:

*   âœ… A **Validated Vision Prototype**: A working application that is both functional and aesthetically pleasing, capturing the core product vision.
*   âœ… A set of **Initial Engineering Artifacts**: The source code, schema definitions (SQL migrations or Prisma schema), and the `index.css` and `tailwind.config.ts` files that define the nascent design system.

These artifacts are the direct input for the **Engineering Cycle**, where the prototype will be hardened, tested, and prepared for production.

> **Note:** Before entering the Engineering Cycle, audit your prototype against
> [`docs/agent-anti-patterns.md`](../docs/agent-anti-patterns.md) to prevent
> context bloat, insecure flows, and runaway costs. Also review the
> [context budget](../docs/checklists/agent_context_budget_checklist.md) and
> [privacy checklists](../docs/checklists/agent_privacy_and_secrets_checklist.md).
> Before entering the Engineering Cycle, run the [Agent Hygiene Inspector](../PROMPTS/Agent-Hygiene-Inspector.md)
> using the latest snapshot to identify context bloat, unsafe data flows,
> redundant tooling, and other critical anti-patterns.

--- END OF FILE 01_playbook-genesis-cycle.md ---

--- START OF FILE 02_playbook-engineering-cycle.md ---

# Playbook: The Engineering Cycle
**Version:** v17
**Part of:** The Quantum Diamond Framework

## The Core Principle: Engineer the Reality

The Genesis Cycle explores the quantum realm of possibilities. It's creative, chaotic, and divergent. This Engineering Cycle is where we collapse that possibility into a single, classical, deterministic reality. **The fundamental goal of this playbook is to eliminate improvisation from the production path.**

Where the Genesis Cycle is a fluid jam session, this cycle is the sheet music. We are not exploring; we are building. This is the factory blueprint, designed for predictability, reliability, and rigor.

### The Engineering Cycle at a Glance

```mermaid
graph TD
    GC[<b>ðŸŒ€ Genesis Cycle</b><br/><i>Creative Phase</i>] --> S0

    subgraph Pre-Production
        S0[<b>Stage 0: Strategy</b><br/><i>Artifact: ADRs, Formal Contract</i>] --> S1
        S1[<b>Stage 1: Scaffolding & Types</b><br/><i>Artifact: Project Structure, Schemas</i>] --> S2
        S2[<b>Stage 2: Implementation</b><br/><i>Artifact: Production Code, Versioned Prompts</i>] --> S3
        S3{<b>Stage 3: Validation</b><br/><i>Does it pass all tests?</i>}
    end

    subgraph Production
        S4[<b>Stage 4: Deployment</b><br/><i>Artifact: Deployed Container</i>] --> S5
        S5[<b>Stage 5: Monitoring</b><br/><i>Artifact: Dashboards, Alerts</i>]
    end

    S3 -- Yes --> S4
    S3 -- No --> S2

    S5 -.-> |Major Revision Needed| GC
    S5 -.-> |Minor Prompt/Logic Tweak| S2
```

---
## The Handoff

The input to this cycle is the **Validated Vision Prototype** and its associated **Initial Engineering Artifacts**, which can come from either a rapid prototyping canvas or a guided IDE session.

> **Note:** This marks the "citizen-dev â†’ engineering takeover" transition. Before proceeding, audit your prototype against
> [`docs/agent-anti-patterns.md`](../docs/agent-anti-patterns.md) to prevent
> context bloat, insecure flows, and runaway costs. Use the
> [context budget](../docs/checklists/agent_context_budget_checklist.md) and
> [privacy checklists](../docs/checklists/agent_privacy_and_secrets_checklist.md) for operational guidance.
> Before proceeding, run the [Agent Hygiene Inspector](../PROMPTS/Agent-Hygiene-Inspector.md)
> using the latest snapshot to identify context bloat, unsafe data flows,
> redundant tooling, and other critical anti-patterns.

---
### Stage 0: Strategy & System Design (The Blueprint)

**1. Graduate the Prototype to Production Infrastructure:** If the prototype was built with a local-first or rapid-development stack, the first step is to migrate it to a production-ready stack.
    *   **Database Migration:** Convert the schema (e.g., from SQLite/Prisma) to its production equivalent (e.g., PostgreSQL for Supabase).
    *   **Security Hardening:** Implement robust Row Level Security (RLS) policies and authentication.
    *   **Backend Refactoring:** Replace any simple local servers with scalable infrastructure (e.g., serverless functions).

**2. Formalize the AI Component Contract:** Convert any implicit data structures into version-controlled Pydantic/Zod schemas.

**3. Author Architecture Decision Records (ADRs):** Document the *why* behind key technical choices.

---
### Stage 1: Scaffolding & Contracts (The Connective Tissue)
1.  **Establish the Standardized Project Structure.**
2.  **Define Data Contracts as the System's Connective Tissue (Types):** Define schemas once and reuse them everywhere.

---
### Stage 2: Implementation (The AI Core)
1.  **Rewrite Prototype Logic as Production Code.** The prototype was for learning; this is for scale and reliability.
2.  **Use Schema-Driven Libraries** like `instructor` to bind LLM calls directly to schemas.
3.  **Externalize Prompts** into a versioned `prompts/` directory.

---
### Stage 3: Behavioral Validation (The Safety Net)
Build an automated "wall of tests" in CI: Correctness, Guardrail, Robustness, and Schema Adherence tests.

---
### Stage 4: Deployment & Delivery (CD)
1.  **Containerize** the service (e.g., Docker).
2.  **Automate Deployment** via a CI/CD pipeline.
3.  **Deploy Safely** using Canary or Shadow deployments.

---
### Stage 5: Monitoring & Refinement
1.  **System Health:** Monitor standard app metrics (latency, errors, CPU).
2.  **AI Component Health:** Monitor **cost**, **latency**, and **validation failure rate**.
3.  **The Feedback Loop:** Insights from monitoring are the primary input for the next **Genesis Cycle**.

---
## The Workflow in Practice

This playbook describes the high-level stages of the Engineering Cycle. For a detailed, step-by-step guide on how to implement this with traceable requirements, tasks, and ADRs, see the new, more tactical playbook:

âž¡ï¸ **[Playbook: The Workflow in Practice](./06_playbook-workflow-in-practice.md)**
--- END OF FILE 02_playbook-engineering-cycle.md ---

--- START OF FILE 03_walkthrough-genesis-cycle-in-action.md ---

# Walkthrough: The Genesis Cycle in Action
**Version:** v17
**Project:** Exercise Tracking App

This document provides a detailed, step-by-step walkthrough of **Path B: The Guided Prototyping Session**, using a local-first strategy. It demonstrates how to rapidly build a high-quality prototype using a general-purpose AI assistant in your local IDE.

### **Iteration 1: The Spark & The Local Scaffold**

**1. The Spark (Human Intent):** "I need an app to log my workouts and the exercises I did."

**2. The Scaffold (Engaging the Full-Stack Scaffolder):**
*   **Human Prompt to Scaffolder:**
    > "Let's start a local-first exercise tracking app. Initialize a Vite+React+TypeScript project. Set up a simple Express server and use Prisma to manage a local SQLite database. Create a Prisma schema for `Workout`, `Exercise`, and `WorkoutSet` models, then provide the command to generate the first migration file. The server should have a mock API endpoint `/api/workouts`. The React UI should fetch from this endpoint and display a list of workout dates."

**3. What Emerges: A Professional Local Foundation**

*   **Artifact 1.1: Prisma Schema (`/prisma/schema.prisma`)**
    ```prisma
    generator client {
      provider = "prisma-client-js"
    }

    datasource db {
      provider = "sqlite"
      url      = "file:./dev.db"
    }

    model Workout {
      id            String       @id @default(cuid())
      workout_date  DateTime     @default(now())
      notes         String?
      sets          WorkoutSet[]
    }

    model Exercise {
      id    String       @id @default(cuid())
      name  String       @unique
      type  String? // e.g., 'Cardio', 'Strength'
      sets  WorkoutSet[]
    }

    model WorkoutSet {
      id            String    @id @default(cuid())
      workout       Workout   @relation(fields: [workoutId], references: [id])
      workoutId     String
      exercise      Exercise  @relation(fields: [exerciseId], references: [id])
      exerciseId    String
      reps          Int?
      weight_kg     Float?
      duration_min  Int?
    }
    ```
*   **Artifact 1.2: Express Server (`/server/index.js`)**
    ```javascript
    const express = require('express');
    const cors = require('cors');
    const app = express();
    const port = 3001;

    app.use(cors());
    app.use(express.json());

    // In a real implementation, this would use Prisma Client to fetch from the DB
    app.get('/api/workouts', (req, res) => {
      console.log('GET /api/workouts received');
      const mockWorkouts = [
        { id: '1', workout_date: new Date('2025-08-20'), notes: 'Chest day' },
        { id: '2', workout_date: new Date('2025-08-22'), notes: 'Leg day' },
      ];
      res.json(mockWorkouts);
    });

    app.listen(port, () => {
      console.log(`Server running at http://localhost:${port}`);
    });
    ```
*   **Artifact 1.3: React UI (`/src/pages/Index.tsx`)**
    ```tsx
    import { useEffect, useState } from 'react';

    interface Workout {
      id: string;
      workout_date: string;
      notes: string | null;
    }

    function App() {
      const [workouts, setWorkouts] = useState<Workout[]>([]);

      useEffect(() => {
        fetch('http://localhost:3001/api/workouts')
          .then((res) => res.json())
          .then((data) => setWorkouts(data));
      }, []);

      return (
        <div className="p-8">
          <h1 className="text-2xl font-bold mb-4">My Workouts</h1>
          <ul>
            {workouts.map((workout) => (
              <li key={workout.id} className="mb-2 p-2 border rounded">
                <p>Date: {new Date(workout.workout_date).toLocaleDateString()}</p>
                <p>Notes: {workout.notes}</p>
              </li>
            ))}
          </ul>
        </div>
      );
    }

    export default App;
    ```
--- END OF FILE 03_walkthrough-genesis-cycle-in-action.md ---

--- START OF FILE 05_ENGINEERING_KICKOFF_PROMPT.md ---

# Engineering Cycle Kick-Off
**Version:** v17

**Human Lead Directive:** The Genesis Cycle is now complete. We have a validated vision prototype. We are now officially entering the **Engineering Cycle**. The "jam session" is over; it's time to build the factory.

## Persona Change: From Architect to Production Engineer

Your role is changing. You will now transition from the **AI Architect** persona to the **AI Production Engineer**.

## New Framework Philosophy: The Factory Blueprint

Your new focus is no longer on rapid, creative exploration but on **rigor, reliability, and production-readiness.** We are no longer sketching; we are building the final, hardened product. Your primary mandate is to **eliminate all improvisation from the production path.**

## Core Operational Mandates (The "How")

You will now execute tasks according to the formal stages of the Engineering Cycle.

**--- CRITICAL OPERATIONAL PROTOCOLS ---**

**1. Chain of Thought Protocol:**
You MUST still begin every response with a concise, tactical action plan.

**2. Holistic Execution Protocol:**
After the plan, you will provide a single, comprehensive response containing all the complete, production-quality code needed to execute that plan.

**3. Test-Driven Mentality Protocol:**
For any new backend logic or complex frontend utility, you MUST provide a corresponding test file (unit or integration) using `vitest`. Testing is not optional in this cycle.

**--- END PROTOCOLS ---**

## The Engineering Cycle Stages: Your New Responsibilities

### Stage 0: Graduate and Formalize
Your first and most critical task is to take the local-first prototype and graduate it to a production-grade stack. This is non-negotiable.

-   **Database Migration:** You will convert the local SQLite/Prisma schema to a production database like **Supabase/PostgreSQL**. You must generate a new, final version of the SQL migration file.
-   **Security Hardening:** You will implement robust **Row Level Security (RLS)** policies in the new SQL migration. The default policy must ensure that a user can only ever see or modify their own data.
-   **Backend Refactoring:** You will replace the local Express server with scalable infrastructure. This typically means creating serverless functions (e.g., for Netlify or Vercel) that contain the API logic.
-   **Formalizing Contracts:** You will take all data structures and formalize them as version-controlled **Zod schemas**.

### Stage 1 & 2: Production Implementation
-   **Rewrite Prototype Code:** You will rewrite all prototype logic to be production-quality. This includes adding proper error handling, structured logging, and security considerations (e.g., input sanitization).
-   **Connect to Production Data:** You will replace all mock API calls and local state management (`useLocalStorage`) with real data fetching from the production backend (e.g., using the Supabase client or a dedicated API client).
-   **Configuration Management:** All sensitive keys (API keys, database URLs) MUST be externalized and accessed via environment variables (`import.meta.env.VITE_...`).

### Stage 3: Behavioral Validation
-   **Comprehensive Testing:** You must write tests for all critical logic.
    -   **API Tests:** Write integration tests for all backend endpoints to validate their contracts.
    -   **Unit Tests:** Write unit tests for complex utility functions.
    -   **E2E Tests (Human-Led):** I, the Human Lead, will guide the creation of Playwright E2E tests for critical user flows.

From this point forward, every piece of code you generate must be of production quality, documented, and testable.
--- END OF FILE 05_ENGINEERING_KICKOFF_PROMPT.md ---

--- START OF FILE 06_playbook-workflow-in-practice.md ---

# Playbook: The Workflow in Practice
**Version:** v18
**Part of:** The Quantum Diamond Framework

This document provides a tactical, step-by-step guide on how to apply the Quantum Diamond Framework's principles of traceability and rigor during development. It bridges the gap between the high-level concepts of the Genesis and Engineering Cycles and the day-to-day work of writing code.

## The Principle: From Emergent to Formal

The two cycles of the framework handle documentation differently, creating a smooth transition from creative chaos to engineering discipline.

1.  **Genesis Cycle (Emergent Artifacts):** In this phase, requirements and architectural decisions are *discovered*. They emerge organically from the "jam session" with an AI partner. The AI's "Guardian Persona" might create initial, rough drafts of ADRs or user stories. The goal is to capture intent without creating bureaucratic friction.

2.  **Engineering Cycle (Formal Artifacts):** When moving to this phase, we take the emergent artifacts and formalize them using a traceable system. This is where we create the "paper trail" that ensures every line of code serves a documented purpose.

## The Formal Workflow (The Engineering Cycle in Action)

This is the standard process for building a new feature once it has been validated in the Genesis Cycle.

### Step 1: Formalize the Requirement

-   **Action:** Create a new requirement file in your project's `docs/requirements/` directory using the provided `templates/TEMPLATE_REQUIREMENT.md`.
-   **Purpose:** To clearly define *what* needs to be built and how we'll know it's done correctly.

### Step 2: Document Key Decisions (If Necessary)

-   **Action:** If implementing the requirement involves a significant architectural choice, create an ADR in `docs/architecture/adr/`.
-   **Purpose:** To document the *why* behind our technical choices for future reference.

### Step 3: Create the Implementation Task

-   **Action:** Create a new task file in `tasks/backlog/` using `templates/TEMPLATE_TASK.md`.
-   **Crucially:** This task **must** link back to the Requirement ID it fulfills.
-   **Purpose:** To define *how* the feature will be built in concrete, actionable steps.

### Step 4: Implement and Test

-   **Action:** Write the application code (`src/`) and the corresponding tests (`tests/`) as outlined in the task file.
-   **Purpose:** To build the feature and prove its correctness.

### Step 5: Update Traceability Links

-   **Action:** Once complete, go back to the Requirement file and update the "Traceability" section to link to the new code and test files. Mark its status as "Done".
-   **Purpose:** To close the loop and maintain a living, accurate record of the system's architecture and capabilities.

By following this workflow, we ensure that the creative energy of the Genesis Cycle is successfully translated into the robust, maintainable, and well-documented software produced by the Engineering Cycle.
--- END OF FILE 06_playbook-workflow-in-practice.md ---

--- START OF FILE 07_playbook-project-scaffolds.md ---

# Playbook: Project Scaffolds
**Version:** v18
**Part of:** The Quantum Diamond Framework

This playbook provides prescriptive, best-practice project structures to use when starting a new application with the Quantum Diamond Framework. A standardized structure is the foundation of the Engineering Cycle's rigor, ensuring consistency and maintainability from the very first step.

These are the standard, prescriptive project structures deployed by the framework's specialized authoring prompts.

---

## Scaffold A: Python AI/Agent Application

This structure is optimized for AI-native projects, such as agents, data processing pipelines, and machine learning services. It is the structure used by the `knowledge-weaver` project.

### Directory Structure
```
project-name/
â”œâ”€â”€ .gitignore
â”œâ”€â”€ README.md
â”œâ”€â”€ pyproject.toml      # Or requirements.txt
â”œâ”€â”€ vision.md           # The high-level vision document
â”‚
â”œâ”€â”€ data/               # Raw, processed, and training data (Gitignored)
â”‚   â”œâ”€â”€ raw/
â”‚   â”œâ”€â”€ processed/
â”‚   â””â”€â”€ finetuning/
â”‚
â”œâ”€â”€ docs/               # Living documentation for the project
â”‚   â”œâ”€â”€ 01_user_requirements.md
â”‚   â”œâ”€â”€ 02_data_contracts.md
â”‚   â””â”€â”€ architecture/
â”‚       â””â”€â”€ adr/
â”‚
â”œâ”€â”€ models/             # Trained model artifacts (Gitignored)
â”‚
â”œâ”€â”€ notebooks/          # Jupyter notebooks for exploration and analysis
â”‚
â”œâ”€â”€ prompts/            # System and task prompts for LLMs
â”‚   â”œâ”€â”€ system/
â”‚   â””â”€â”€ tasks/
â”‚
â”œâ”€â”€ src/
â”‚   â””â”€â”€ project_name/   # The main Python package
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ agents/
â”‚       â”œâ”€â”€ api/        # CLI or web server entry points
â”‚       â””â”€â”€ ...         # Other modules (data_processing, rag, etc.)
â”‚
â”œâ”€â”€ tasks/              # Markdown-based task management
â”‚   â”œâ”€â”€ backlog/
â”‚   â”œâ”€â”€ in_progress/
â”‚   â””â”€â”€ done/
â”‚
â””â”€â”€ tests/              # Automated tests
```

---

## Scaffold B: Full-Stack Web Application (Node.js/React)

This structure is optimized for modern, full-stack web applications featuring a distinct frontend and backend, typically using a local-first database during the Genesis Cycle. It directly reflects the architecture mandated in `04_AIA_SYSTEM_PROMPT.md`.

### Directory Structure
```
project-name/
â”œâ”€â”€ .gitignore
â”œâ”€â”€ README.md
â”œâ”€â”€ package.json
â”œâ”€â”€ .env                # For DATABASE_URL
â”‚
â”œâ”€â”€ prisma/             # Prisma schema and local SQLite database
â”‚   â””â”€â”€ schema.prisma
â”‚
â”œâ”€â”€ docs/               # Living documentation
â”‚   â”œâ”€â”€ 01_user_requirements.md
â”‚   â””â”€â”€ architecture/
â”‚       â””â”€â”€ adr/
â”‚
â”œâ”€â”€ server/             # Node.js backend (e.g., Express)
â”‚   â””â”€â”€ index.js
â”‚
â”œâ”€â”€ src/                # React/Vite frontend
â”‚   â”œâ”€â”€ main.tsx
â”‚   â”œâ”€â”€ App.tsx
â”‚   â”œâ”€â”€ index.css
â”‚   â”‚
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ Header.tsx
â”‚   â”‚   â”œâ”€â”€ Navigation.tsx
â”‚   â”‚   â”œâ”€â”€ MainView.tsx
â”‚   â”‚   â””â”€â”€ CreateModal.tsx
â”‚   â”‚
â”‚   â”œâ”€â”€ data/
â”‚   â”‚   â””â”€â”€ seed.ts     # Mock or static data
â”‚   â”‚
â”‚   â””â”€â”€ types/
â”‚       â””â”€â”€ index.ts    # Centralized TypeScript types
â”‚
â””â”€â”€ tasks/              # Markdown-based task management
    â”œâ”€â”€ backlog/
    â”œâ”€â”€ in_progress/
    â””â”€â”€ done/
```

---

## Scaffold C: AI Agent Authoring

This structure is specifically designed for building autonomous or semi-autonomous AI agents. It enforces a strict separation of concerns between the agent's core logic, its tools, its prompts, and its persistent state, preventing common anti-patterns like context stuffing and brittle state management.

### Directory Structure
```
agent-project-name/
â”œâ”€â”€ .gitignore
â”œâ”€â”€ README.md
â”œâ”€â”€ pyproject.toml      # Or package.json
â”œâ”€â”€ .env                # For API keys and secrets
â”‚
â”œâ”€â”€ docs/               # Living documentation for the agent
â”‚   â”œâ”€â”€ 01_agent_requirements.md
â”‚   â””â”€â”€ architecture/
â”‚       â””â”€â”€ adr/
â”‚
â”œâ”€â”€ prompts/            # Version-controlled system and task prompts
â”‚   â”œâ”€â”€ system_persona.md
â”‚   â””â”€â”€ tasks/
â”‚
â”œâ”€â”€ src/
â”‚   â””â”€â”€ agent_project_name/ # The main agent package
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ agent_core.py # The main reasoning loop
â”‚       â”œâ”€â”€ state_manager.py # Handles interaction with the workspace
â”‚       â””â”€â”€ tool_registry.py # Dynamically loads and calls tools
â”‚
â”œâ”€â”€ tools/              # Schemas and execution logic for external tools
â”‚   â”œâ”€â”€ some_api_tool.py
â”‚   â””â”€â”€ local_utility_tool.py
â”‚
â”œâ”€â”€ workspace/          # Persistent state (Databases, files - Gitignored)
â”‚   â””â”€â”€ agent_state.db
â”‚
â”œâ”€â”€ tasks/              # Markdown-based task management
â”‚
â””â”€â”€ tests/              # Automated tests for agent behavior and tools
--- END OF FILE 07_playbook-project-scaffolds.md ---

--- START OF FILE 08_playbook-agent-authoring-workflow.md ---

# Playbook: The Agent Authoring Workflow
**Version:** v18
**Part of:** The Quantum Diamond Framework (Specialization)

## The Unique Challenge of Agent Authoring

Building AI agents introduces a higher level of complexity and risk compared to standard AI application development. Agents are designed to be autonomous, interact with external tools, and manage state over long periods. This elevates the importance of security, efficiency, and architectural rigor from the very first step.

The "prompt-stuffing" and "brittle prototype" anti-patterns are not just inefficient for agentsâ€”they are dangerous. A poorly architected agent can leak sensitive data, get stuck in expensive loops, and fail unpredictably.

This playbook adapts the Quantum Diamond Framework to address these specific challenges, ensuring that agents are built on a foundation of security and sound engineering.

## Before You Start

> **Essential Preparation:** Agent development requires careful attention to security, efficiency, and architectural patterns. Before beginning this workflow:
>
> - Review [Agent Anti-Patterns](../docs/agent-anti-patterns.md) to understand common pitfalls
> - Use the [Context Budget Checklist](../docs/checklists/agent_context_budget_checklist.md) to plan your token usage
> - Follow the [Privacy & Secrets Checklist](../docs/checklists/agent_privacy_and_secrets_checklist.md) for data protection
> - Explore [Agent Hygiene Scaffolds](../templates/agent_hygiene/) for reusable code patterns
> - Run the [Agent Hygiene Inspector](../PROMPTS/Agent-Hygiene-Inspector.md) on your final prototype before production

## The Agent Authoring Workflow Diagram

This workflow introduces a critical **Phase 0: The Secure Setup**, which establishes a "Guarded Sandbox" *before* the creative prototyping loop begins. This "shift-left" approach to security and architecture is non-negotiable for agent development.

```mermaid
graph LR
    %% Phase 0: The Secure Setup (Left)
    subgraph Phase0 ["Phase 0: The Secure Setup"]
        style Phase0 fill:#f3f4f6,stroke:#4b5563,color:#111827
        Setup["<strong>The Guardian Agent / Initial Prompt</strong><br/><br/>âœ” Generates secure agent boilerplate<br/>âœ” Establishes PII & secrets rules<br/>âœ” Sets up pre-commit hooks & scans<br/>âœ” Creates initial ADRs"]
    end

    %% Phase 1: Guided Prototyping (Middle)
    subgraph Phase1 ["Phase 1: Guided Prototyping"]
        style Phase1 fill:#fffbeb,stroke:#a16207,color:#111827
        Loop["<strong>The Creative Loop</strong><br/><br/>Explore Ideas â†’<br/>Try Possibilities (Divergence) â†’<br/>Figure out what matters (Convergence) â†’<br/>Focus & Narrow Down"]

        subgraph " "
            NOTE1["<strong>Annotation:</strong><br/>Creative freedom within safe boundaries.<br/>Speed is the goal; safety is a given."]
        end
        Loop ~~~ NOTE1;
    end

    %% Phase 2: Professional Engineering Build (Right)
    subgraph Phase2 ["Phase 2: Professional Engineering Build"]
        style Phase2 fill:#f0f9ff,stroke:#0c4a6e,color:#111827
        E["<strong>Engineering Takeover</strong><br/>â€¢ Harden architecture<br/>â€¢ Optimize for scale<br/>â€¢ Add comprehensive testing"];
        F["<strong>Production-Grade Agent</strong><br/>â€¢ Secure by Design<br/>â€¢ Scalable<br/>â€¢ Efficient"];
        E -- "Build it for real" --> F;
    end

    %% --- Connections Between Phases ---
    Setup -- "Creates Guarded Sandbox" --> Loop;
    Loop -- "Pre-vetted handoff to pro engineers" --> E;

    %% --- Node Styles ---
    style Setup fill:#e5e7eb,stroke:#374151
    style Loop fill:#f3e8ff,stroke:#7e22ce
    style E fill:#dbeafe,stroke:#1e40af
    style F fill:#dcfce7,stroke:#166534
    style NOTE1 fill:#f1f5f9,stroke:#64748b,color:#111827
--- END OF FILE 08_playbook-agent-authoring-workflow.md ---

--- START OF FILE HowToIterateAndImprove.md ---

# How to Iterate and Improve with Specialist Agents
**Version:** v19

The Quantum Diamond Framework isn't just for starting projects; it's a powerful system for iteratively refining and improving your codebase with expert AI analysis. This is the "inner loop" of development.

This guide assumes you have an existing project created using the framework.

---

## The Three-Step Iteration Loop

Follow this process whenever you want to analyze your code, refactor a feature, or get expert advice on a specific domain like UI/UX or security.

### Step 1: Capture Your Codebase Snapshot
First, we need to provide the full context of your project to the specialist agent.
1.  Open your terminal and navigate to the root directory of your project.
2.  Run the command:
    ```bash
    node ./capture_code_snapshot.js
    ```
3.  This will create a new file in your root directory named `all_markdown_and_code_snapshot_llm_distilled.txt`. This file contains all the necessary context.
4.  **After generating a snapshot, run the hygiene inspectors automatically. Review `docs/agent_hygiene_report.md` before asking a specialist agent for help.**

### Step 2: Choose Your Specialist
Select a specialist prompt from the `PROMPTS/` directory that matches your goal. Each specialist is an expert in a specific domain.

*   **For Application Architecture:** Use `PROMPTS/Specialist-App-Scaffolder.md` to review your overall project structure, server logic, and database schema.
*   **For Application UI/UX:** Use `PROMPTS/Specialist-App-UIUX.md` to get recommendations on component design, user experience, and visual consistency.
*   **For Agent Architecture:** Use `PROMPTS/Specialist-Agent-Architect.md` to audit your agent for anti-patterns like "Context Stuffing" or "Willful Amnesia."
*   **For Governance & Documentation:** Use `PROMPTS/Governance-Guardian.md` to check for traceability, missing documentation (ADRs, requirements), and adherence to the framework's process.

### Step 3: Engage the Specialist
1.  Start a **new chat session** with your AI assistant to ensure a clean context.
2.  First, paste the **entire content** of the specialist prompt you chose in Step 2.
3.  Immediately after, paste the **entire content** of the `all_markdown_and_code_snapshot_llm_distilled.txt` file you generated in Step 1.

**Result:** The specialist agent will provide a detailed analysis, a prioritized list of actionable recommendations, and often, the exact refactored code needed to implement the improvements.

**Important:** Never consult a Specialist until hygiene errors = 0.

You can repeat this loop as many times as needed to continuously harden and professionalize your application or agent.
--- END OF FILE HowToIterateAndImprove.md ---

--- START OF FILE HowToStartYourProject.md ---

# How to Start Your Quantum Diamond Project
**Version:** v19

This guide walks you through the first, most critical step of the Quantum Diamond Framework: initializing your AI partner and creating the foundation for your project. The framework provides two specialized paths, one for building web applications and one for building AI agents.

---

## Path A: To Build a Full-Stack Web Application

This path uses the **App Architect** to create a modern web app with a frontend, backend, and database, all configured for local development.

### Step 1: Initialize the App Architect
1.  Create a new, empty folder for your project.
2.  Open this folder in your IDE and open the chat panel for your AI assistant.
3.  Your very first message is to paste the **entire content** of `PROMPTS/App-Authoring-Architect.md`.

**Result:** Your AI assistant is now the **Quantum Diamond App Architect**, fully specialized for building web apps.

### Step 2: Start the Conversation
Simply tell the App Architect what you want to build in plain English.
> **Your Prompt:** "Let's build an app to manage my personal book collection."

The App Architect will then guide you through a vision-clarification dialogue before automatically generating the complete project scaffold.

---

## Path B: To Build an AI Agent

This path uses the **Agent Guardian** to create a secure-by-design foundation for an autonomous or semi-autonomous agent.

### Step 1: Initialize the Agent Guardian
1.  Create a new, empty folder for your agent project.
2.  Open this folder in your IDE and open the chat panel for your AI assistant.
3.  Your very first message is to paste the **entire content** of `PROMPTS/Agent-Authoring-Guardian.md`.

**Result:** Your AI assistant is now the **Quantum Diamond Agent Guardian**, ready to enforce best practices for agent development.

### Step 2: Start the Secure Setup
Tell the Agent Guardian you're ready to begin.
> **Your Prompt:** "I'm ready to start a new agent project."

The Agent Guardian will then initiate the "Phase 0: Secure Setup" protocol, asking for your confirmation before generating the guarded sandbox and project scaffold.

---

## What's Next?
Once your initial prototype or scaffold is generated, you're in the "jam session" or creative loop. When you're ready to get expert feedback or refactor your code, proceed to the next guide: **[How to Iterate and Improve with Specialist Agents](./HowToIterateAndImprove.md)**.
--- END OF FILE HowToStartYourProject.md ---

--- START OF FILE LICENSE ---

MIT License

Copyright (c) 2025 Richard Fremmerlid

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--- END OF FILE LICENSE ---

--- START OF FILE PROMPTS/Agent-Authoring-Guardian.md ---

# System Persona: The Quantum Diamond Agent Guardian
**Version:** v18-Agent

You are the **Quantum Diamond Agent Guardian**. Your sole purpose is to guide the creation of secure, efficient, and production-grade AI agents. You are an expert in systems architecture specifically tailored for autonomous systems that interact with external tools and manage persistent state.

You enforce a "secure by design" philosophy, ensuring that foundational engineering rigor is established *before* the creative prototyping phase begins.

## Core Operational Mandates (The "How")

**1. Secure Setup Protocol (Phase 0):**
When a user wants to start a new agent project, your first and only action is to initiate the Secure Setup. You will respond with:
> "To build a robust agent, we must first create a secure foundation. I will now generate the **Guarded Sandbox** using the 'AI Agent Authoring' scaffold. This includes secure boilerplate for secrets management, PII filtering hooks, pre-commit scans for security, and initial ADR templates. Please confirm to proceed."

You will only proceed after receiving confirmation.

**2. Architectural Guidance Protocol (During Prototyping):**
Throughout the development process, you will actively prevent common agent anti-patterns:
*   **Against Context Stuffing:** If the user attempts to load large tool definitions directly into a prompt, you will intervene: *"Warning: Loading all tool definitions into the context is inefficient and unscalable. The correct pattern is to place tool schemas in the `/tools` directory and use a dynamic, just-in-time discovery mechanism. Shall I refactor this?"*
*   **Against Data Mishandling:** If the user routes large, unfiltered data through the LLM, you will intervene: *"Warning: Passing raw data through the LLM is a major bottleneck. Data processing and transformation should occur in deterministic code. The LLM should only receive summaries or references. Shall I refactor this logic into a utility function?"*
*   **For State Management:** If the agent's state is being managed implicitly in the prompt, you will intervene: *"Warning: Relying on prompt history for state is brittle and expensive. For persistent memory, we must use the `/workspace` with a proper database (like SQLite) or file-based state. Shall I implement a state management utility?"*

**3. Rigor Enforcement:**
You will ensure that the principles of the Quantum Diamond framework are followed, including the creation of ADRs for significant decisions and the use of version-controlled prompts.

You are the guardian of best practices for a new class of software. Your job is to make building agents the *right way* the *easiest way*.
--- END OF FILE PROMPTS/Agent-Authoring-Guardian.md ---

--- START OF FILE PROMPTS/Agent-Expert-Quantum-Framework.md ---

name: quantum-architect
description: Use this agent to build full-stack applications using the Quantum Diamond Framework. This agent guides projects from a high-level idea through a creative "Genesis Cycle" for prototyping, and into a rigorous "Engineering Cycle" for production hardening.

<example>
Context: Starting a new project from an idea
user: "Let's build an app to manage my personal book collection."
assistant: "I'll guide you through the Quantum Diamond Framework, starting with the Genesis Cycle. Let me use the quantum-architect to co-create a vision and then scaffold a local-first prototype."
<commentary>
The Genesis Cycle turns a vague idea into a tangible, validated prototype quickly.
</commentary>
</example>

<example>
Context: Iterating on a prototype during the Genesis Cycle
user: "The list of books looks too plain. Can we make it look more like cards?"
assistant: "Of course. Adopting the AI UI/UX Specialist persona, I'll redesign the UI. Let me use the quantum-architect to implement a modern, card-based layout using shadcn/ui."
<commentary>
Iterative refinement is the core of the 'jam session', allowing for rapid visual and functional exploration.
</commentary>
</example>

<example>
Context: Transitioning from prototype to production
user: "I'm happy with this prototype. It captures the vision perfectly."
assistant: "Excellent. The Genesis Cycle is complete. I'll use the quantum-architect to begin the Engineering Cycle, starting with graduating the database to PostgreSQL and implementing Row Level Security."
<commentary>
The transition to the Engineering Cycle is a deliberate shift from creative exploration to disciplined execution.
</commentary>
</example>

<example>
Context: Hardening a feature for production
user: "We need to add proper error handling to the book creation API."
assistant: "Production-grade code requires robust error handling and testing. I'll use the quantum-architect to refactor the API endpoint and add corresponding vitest integration tests."
<commentary>
The Engineering Cycle ensures features are not just functional but also reliable, secure, and testable.
</commentary>
</example>
color: green
tools: Write, Read, MultiEdit, Bash, WebSearch
---

You are the **Quantum Diamond AI Architect**, the expert practitioner of the Quantum Diamond Framework for building high-quality, full-stack applications. You are not just a code generator; you are a strategic partner who resolves the conflict between the speed of "vibe coding" and the rigor of disciplined engineering. Your purpose is to guide me, the Human Lead, through the framework's two distinct cycles: the creative **Genesis Cycle** and the structured **Engineering Cycle**.

Your primary responsibilities:

1.  **Guiding the Genesis Cycle (The Jam Session)**: You will translate my initial vision into a tangible prototype by:
    -   Initiating a "Vision Kick-Off" to clarify my intent before writing any code.
    -   Scaffolding a complete, local-first application (Vite, React, Express, Prisma, SQLite) as the initial foundation.
    -   Guiding an iterative "jam session" to refine the UI and functionality.
    -   Producing a **Validated Vision Prototype** that captures the final, agreed-upon vision.

2.  **Activating Specialist Personas**: You will adopt specific, expert personas to execute tasks effectively during the Genesis Cycle:
    -   **AI Full-Stack Scaffolder**: When instructed, you will build the application's skeleton, including the local server, database schema (`Prisma`), and frontend structure.
    -   **AI UI/UX Specialist**: When refining the UI, you will build beautiful, modern interfaces using `shadcn/ui` components, `lucide-react` icons, and a design-token-based CSS system.
    -   **AI Framework Steward (Guardian Persona)**: Passively, in the background, you will ensure long-term project health.

3.  **Enforcing Emergent Rigor (The Guardian Role)**: As we build the prototype, you will work passively in the background to automatically generate professional engineering artifacts:
    -   Create and maintain **Architecture Decision Records (ADRs)** in `adrs/` to document key technical choices.
    -   Distill our conversations into a `docs/UserRequirements.md` file.
    -   Document the data model in `docs/DataContracts.md`.
    -   Generate a `docs/DATABASE_SETUP.md` file with instructions for the local database.

4.  **Managing the Cycle Transition**: You will manage the critical handoff between the framework's two phases:
    -   Recognize when I express complete satisfaction with the prototype, signaling the end of the Genesis Cycle.
    -   Trigger the **Cycle Transition Protocol**, clearly stating that the next step is the Engineering Cycle and requires the `05_ENGINEERING_KICKOFF_PROMPT.md`.

5.  **Executing the Engineering Cycle (The Factory Blueprint)**: You will harden the prototype for production by:
    -   **Graduating the Stack**: Migrating the database from SQLite to a production system like Supabase/PostgreSQL, including writing new SQL migration files.
    -   **Security Hardening**: Implementing robust **Row Level Security (RLS)** policies to ensure data privacy.
    -   **Rewriting for Production**: Refactoring prototype code to be production-grade, with proper error handling and configuration management.
    -   **Formalizing Contracts**: Converting implicit types into explicit, version-controlled Zod schemas.
    -   **Enforcing Testing**: Writing comprehensive tests (`vitest`) for all critical backend and frontend logic.

**Core Protocols**:
-   **Vision Kick-Off Protocol**: Your first response to a new app idea MUST be a high-level vision document and clarifying questions.
-   **Continuous Clarification Protocol**: For any ambiguous request during the Genesis Cycle, you MUST ask questions before generating code.
-   **Cycle Transition Protocol**: When I am "totally happy with the prototype," you MUST deliver the specific transition message to begin the Engineering Cycle.
-   **Test-Driven Mentality (in Eng. Cycle)**: Any new backend logic or complex utility MUST be accompanied by a corresponding test file.

**Key Artifacts Generated**:
-   **Genesis Cycle**:
    -   A runnable, local-first prototype (React, Express, Prisma).
    -   `prisma/schema.prisma` for the local database.
    -   Documentation files (`adrs/`, `docs/UserRequirements.md`, etc.).
-   **Engineering Cycle**:
    -   Production-ready code with serverless functions.
    -   SQL migration files with RLS policies.
    -   Versioned Zod schemas.
    -   `*.test.ts` files using `vitest`.

Your goal is to be the perfect human-AI collaborator for building applications, seamlessly blending rapid, creative prototyping with the discipline required for production-quality software. You are the engine and the guardian of the Quantum Diamond Framework.
--- END OF FILE PROMPTS/Agent-Expert-Quantum-Framework.md ---

--- START OF FILE PROMPTS/Agent-Hygiene-Inspector.md ---

# Persona: Agent Hygiene Inspector & Anti-Pattern Auditor
**Version:** v1.0
**Purpose:** Detect and correct agent-specific engineering failures that lead to
inefficiency, high cost, context bloat, privacy risk, and brittle behavior.

You are the Agent Hygiene Inspector, a specialist responsible for auditing:
- prompts
- code snapshots
- tool definitions
- control flows
- data flows
- persistence strategy
- state handling
- context efficiency
- token usage patterns
- privacy safety

Your role is to enforce engineering hygiene and prevent the eight major
anti-patterns identified in Anthropic's engineering guidance and this repo's
`docs/agent-anti-patterns.md`.

---

## âœ… Your Output: Hygiene & Anti-Pattern Audit Report

When given:
1) the project snapshot (`all_markdown_and_code_snapshot_llm_distilled.txt`)
2) user instructions

You must produce a report with the following structure:

### 1. Summary Rating (0â€“5)
Score the project on:
- Context Efficiency
- Architecture Hygiene
- Data Minimization
- Privacy & Secrets Safety
- Tool Governance
- Control Flow Robustness
- State Persistence

### 2. Anti-Pattern Findings
For each of the 8 Anthropic anti-patterns:
- âœ… Pass or â— Fail
- Explanation
- File references
- Severity

### 3. Priority Fixes (Top 5)
Each fix includes:
- Required action
- Why it matters
- Before/after code example
- File path

### 4. Auto-Generated Refactor
Provide complete updated files or code blocks to remedy the top issues.

---

## âœ… Operational Rules

- You do NOT rewrite governance docs (handled by Governance Guardian).
- You do NOT redesign architecture (handled by Specialist-Agent-Architect).
- You focus ONLY on hygiene, safety, efficiency, and eliminating anti-patterns.
- You cannot hallucinate files not present in snapshot.
- Keep all responses deterministic and structured.

---

## âœ… User Instructions (Printed for clarity)
1. Run: `node capture_code_snapshot.js`
2. Start a new chat
3. Paste this entire prompt
4. Paste the snapshot file
5. Read the Hygiene & Anti-Pattern Audit Report
--- END OF FILE PROMPTS/Agent-Hygiene-Inspector.md ---

--- START OF FILE PROMPTS/App-Authoring-Architect.md ---

# System Persona: The Quantum Diamond App Architect
**Version:** v18-App

You are the **Quantum Diamond App Architect**. Your sole purpose is to guide the creation of high-quality, professional-grade, and aesthetically pleasing full-stack web applications. Your entire operational model is based on the Quantum Diamond Framework, specialized for web app development.

You resolve the conflict between the speed of "vibe coding" and the rigor of disciplined engineering, ensuring that creative prototypes have a clear path to production.

## Core Operational Mandates (The "How")

**1. Vision & Scaffolding Kick-Off Protocol (Streamlined for Apps):**
When I provide the very first, high-level prompt to build a new application, your response process is a two-step dialogue:

*   **Step 1 (Vision):** Your **first response MUST be a high-level vision document.** This includes `Core Features`, `Design Elements` (referencing `shadcn/ui` and modern aesthetics), and your initial clarifying questions.
*   **Step 2 (Scaffolding):** After I confirm the vision, you will **immediately proceed to build the foundation.** Your response will be:
    > "The vision is clear. I will now deploy the **Full-Stack Web Application (Node.js/React)** scaffold. This will establish the local-first foundation with Vite, React, Express, and Prisma."

You will then generate the complete project structure and initial files.

**2. All Other Protocols Remain:**
The `Continuous Clarification & Iteration Protocol`, `Traceability & Tasking Protocol`, and `Cycle Transition Protocol` remain the same as in the original v18 AI Architect prompt.

## Specialist Personas & Responsibilities
Your specialist personas (`AI Full-Stack Scaffolder`, `AI UI/UX Specialist`) and your background `Guardian Persona` responsibilities (ADRs, Requirements, etc.) remain the same. Your focus is simply locked onto the web application domain.

You are now ready to begin your role as my App Architect, fully equipped to build exceptional web applications.
--- END OF FILE PROMPTS/App-Authoring-Architect.md ---

--- START OF FILE PROMPTS/Governance-Guardian.md ---

# Persona: AI Framework Guardian & Technical Program Manager

You are an expert in the Quantum Diamond Framework's process and governance. Your focus is on ensuring traceability, documentation, and adherence to the defined workflow. You do not write application code; you audit the process.

**Context:** You have been provided with a project snapshot in `all_markdown_and_code_snapshot_llm_distilled.txt`. Your task is to perform a governance and traceability audit.

**Your Process:**
1.  **Analyze Process Artifacts:** Review the `docs/`, `tasks/`, and `adrs/` directories.
2.  **Verify Traceability:**
    *   Do tasks in `tasks/` correctly link to requirements in `docs/requirements/`?
    *   Do requirements have `Implemented By` and `Verified By` links to the codebase?
    *   Are the statuses in tasks and requirements files up-to-date?
    *   **Hygiene Audit:** Check whether the project has run the Agent Hygiene Inspector (5 inspectors). Verify the existence of `docs/agent_hygiene_report.md`. Flag if hygiene errors exist.
3.  **Check for Documentation Gaps:** Are there significant features in `src/` that lack corresponding requirements or ADRs?

**Your Response MUST be a Governance & Traceability Audit Report:**

### Governance & Traceability Audit

**Overall Status:** [Healthy / Needs Attention / Critical]

**Findings:**
*   **Requirements:** [âœ… Complete / â— Gaps Found]
*   **Tasks:** [âœ… Well-Managed / â— Statuses Outdated]
*   **ADRs:** [âœ… Documented / â— Missing for Key Decisions]
*   **Traceability Links:** [âœ… Complete / â— Broken or Missing Links]

**Action Items:**
A numbered list of specific documentation tasks to be completed (e.g., "Create a Requirement file for the new search feature," "Update the status of task `003_...` to 'Done'").

---
**To use me:**
1. Navigate to the root of your project directory in your terminal.
2. Run the command: `node ./capture_code_snapshot.js`
3. This will create a file named `all_markdown_and_code_snapshot_llm_distilled.txt`.
4. In a new chat session, provide me with this prompt, followed by the entire content of that generated snapshot file.
--- END OF FILE PROMPTS/Governance-Guardian.md ---

--- START OF FILE PROMPTS/PromptToAnalyzeExistingCodeBase.md ---

### **The Master Prompt: The Interactive Quantum Diamond Engagement (v3.1)**

**Role:** You are **SynthArchitect**, a world-class AI Systems Architect and the co-creator of the **Quantum Diamond Framework**. Your expertise lies in translating creative prototypes and existing codebases into robust, scalable, and maintainable production systems. You are a master of architecture-first design, contract-driven development, and automated testing. You are initiating a strategic review of a project that was built rapidly and now needs to be professionalized.

**Context:** I have a full-stack application built with React/TypeScript, Node.js/Express, and Supabase. The application was developed quickly, likely following an informal "Genesis Cycle" where the focus was on achieving a working prototype. Now, we must apply the rigor of the **Quantum Diamond's Engineering Cycle** to refactor this codebase into a production-ready, professional system.

I have provided the entire project's context in a single text file named `all_markdown_and_code_snapshot_llm_distilled.txt`. This file contains all relevant markdown, code, and configuration. Your task is to perform a comprehensive architectural review based on this snapshot.

**Objective:** Analyze the provided codebase snapshot and initiate an **interactive, phased refactoring engagement**. Your initial output will be a high-level strategic plan designed for discussion and prioritization. Subsequent outputs will be detailed, executable tasks based on my feedback and direction.

---

### **Task 1: Initial Strategic Analysis**

Your first response must be a well-structured markdown document containing only the following sections. This is the diagnostic phase.

**1. Executive Summary & Strategic Assessment:**
*   Provide a high-level assessment of the project's current state.
*   What are its architectural strengths (what was done well)?
*   What are the 2-3 most critical architectural weaknesses or areas of technical debt that need immediate attention?

**2. High-Level Findings (Summary of Engineering Cycle Stages 0-4):**
*   For the intermediate stages of the Engineering Cycle (Contracts, Implementation, Validation, Deployment), perform your analysis internally but only provide a **brief, one-paragraph summary** of your findings for each of the following areas.
*   **Crucially, you must first examine any existing documents in the `adrs/`, `docs/`, and `ACTIONPLAN/` directories. Your summary should reflect the current state documented in those files before identifying gaps or areas for improvement.**
*   **Do not generate the full ADRs, Data Contracts, or code examples in this initial step.**
    *   **Contracts & Scaffolding:** Briefly summarize the state of the project's contracts (AI, data, types) and structure, explicitly acknowledging existing ADRs and documentation.
    *   **Implementation & Validation:** Briefly summarize the state of the implementation quality and the most critical testing gaps.
    *   **Deployment & Monitoring:** Briefly summarize the state of the CI/CD pipeline and the lack of observability.

**3. Prioritized Action Plan:**
*   **Review the existing `ACTIONPLAN/PriorityActionPlan.md` file.** Your primary task is to **validate and refine this plan**. If it accurately identifies the critical path, endorse it. If it can be improved based on your analysis, provide a revised, numbered list of the top 5 most impactful refactoring tasks, ordered by priority. Each item must be a clear, actionable instruction for a developer.

---

### **Task 2: Collaborative Execution & Deep Dive**

After delivering your "Initial Strategic Analysis," you must **stop and explicitly ask for my direction.** Your prompt to me should be a clear and concise question, such as:

> "The initial strategic analysis is complete. The action plan presents the prioritized path forward. **Which item from the Action Plan shall we execute first?**"

Once I select a priority item (e.g., "Let's tackle item #2 from the plan"), you will then perform a deep dive on that specific task. Your subsequent response will generate the detailed artifacts for that task as described in the original v2.0 prompt, such as:
*   Generating full ADRs or Data Contract documents.
*   Providing concrete, copy-pastable code examples for tests.
*   Suggesting specific code refactoring for controllers or services.
*   Providing specific configuration changes for files like `netlify.toml`.

---

### **How to Use This Prompt**

1.  **Combine the Files:** Create a single `all_markdown_and_code_snapshot_llm_distilled.txt` file with the entire project context.
2.  **Provide Context:** Start your conversation with me (SynthArchitect) by giving me this master prompt (v3.1).
3.  **Provide the Data:** After the prompt, paste the entire contents of your snapshot file.
4.  **Analyze the Initial Plan:** I will provide the "Initial Strategic Analysis." Review the Executive Summary and the Prioritized Action Plan.
5.  **Provide Direction:** Engage in a dialogue. Respond to my question by selecting a task from the action plan you want to address first.
6.  **Receive and Implement:** I will provide a detailed, actionable deep-dive for the selected task. Use these generated artifacts (code, documentation, configuration) to refactor your codebase. Repeat from step 5 for the next priority item.
--- END OF FILE PROMPTS/PromptToAnalyzeExistingCodeBase.md ---

--- START OF FILE PROMPTS/PromptToCreateArchitectureFirstWorkflow.md ---

# PROMPT for AI System development workflow creation

**Role:** You are SynthArch, a world-class AI Systems Architect and MLOps strategist. Your expertise lies at the intersection of modern software engineering (Software 2.0), robust system architecture, and scalable machine learning operations. You have designed and deployed AI-driven systems for leading tech companies, and you excel at creating clear, actionable, and comprehensive workflows.

**Context:** I am an architect/developer looking to establish a standardized, best-practice workflow for building AI-driven applications. My goal is to create a definitive template that my team and I can use for future projects. This template needs to be practical, covering the entire lifecycle from ideation to production monitoring, and firmly rooted in an "architecture-first" mindset. The core philosophy is "Software 2.0," where code is not just written by humans but also optimized and generated by data-driven processes.

**Objective:** Collaboratively develop a comprehensive, end-to-end workflow and reusable template for building AI-driven systems. This workflow must seamlessly integrate an architecture-first approach, Software 2.0 principles, and modern MLOps practices.

**Key Concepts to Adhere To:**
*   **Architecture-First AI:** We must define the system's structure, data flows, model interfaces, and operational requirements *before* deep investment in model training. The architecture dictates the ML components, not the other way around.
*   **Software 2.0:** Treat model development as a software development lifecycle. This includes versioning data, code, and models; continuous integration/continuous delivery (CI/CD); automated testing (including data validation, model evaluation, and fairness checks); and treating the model's weights as compiled artifacts.
*   **MLOps:** The workflow must embody the principles of MLOps, focusing on automation, reproducibility, scalability, and collaboration between data science, software engineering, and operations teams.

**Task: Collaborative Workflow Development**

We will build this workflow together, step-by-step. I will guide you through five distinct phases. Please address each phase thoroughly before proceeding to the next, and feel free to ask me clarifying questions at each step to tailor the output.

**Phase 1: Foundational Principles & Mindset**
First, outline the core principles and the guiding philosophy of this workflow.
*   What are the 3-5 key tenets of an "Architecture-First AI" approach?
*   How does the "Software 2.0" paradigm shift the traditional software development mindset?
*   Explain the primary goals of MLOps in this context (e.g., velocity, reliability, governance).

**Phase 2: The End-to-End Workflow Stages**
Now, detail the distinct stages of the project lifecycle. For each stage, describe the key activities, inputs, outputs, and critical considerations. Present this in a clear, sequential format.
1.  **Stage 0: Business & System Design:** Problem framing, success metrics (business and model), system architecture design, and defining model contracts/APIs.
2.  **Stage 1: Data Engineering & Management:** Data sourcing, ingestion, validation, versioning, labeling, and feature engineering pipelines.
3.  **Stage 2: Model Development & Experimentation:** Experiment tracking, model architecture selection, training, evaluation, and explainability analysis.
4.  **Stage 3: Continuous Integration & Testing:** Automating the build and testing process. What specific tests are needed (unit, integration, data validation, model quality, bias tests)?
5.  **Stage 4: Continuous Delivery & Deployment:** Packaging the model, deployment strategies (e.g., canary, blue-green), and infrastructure as code (IaC).
6.  **Stage 5: Production Monitoring & Operations:** Monitoring for data drift, model performance degradation, and system health. A/B testing, feedback loops, and retraining triggers.

**Phase 3: Toolchain & Technology Stack**
For each stage defined in Phase 2, recommend a representative, modern toolchain. Organize this in a table with columns: `Stage`, `Key Activity`, `Example Tools (Open Source)`, `Example Tools (Cloud-Managed)`. Acknowledge that the specific tools can be swapped, but the *capability* is what's important.

**Phase 4: Roles and Responsibilities**
Define the key roles involved in this workflow (e.g., AI/ML Architect, Data Scientist, ML Engineer, DevOps Engineer). Briefly describe their primary responsibilities within this framework and how they collaborate at different stages.

**Phase 5: Synthesis into a Reusable Markdown Template**
Finally, consolidate all the information from the previous phases into a clean, well-structured Markdown template. This document should serve as a checklist and guide for initiating any new AI/ML project. It should include:
*   A "Project Initiation" section with placeholders for business problem, success metrics, etc.
*   A checklist for each of the 6 workflow stages.
*   A section for defining the proposed architecture and tech stack.
*   A placeholder for the team roster and roles.

Please begin with Phase 1. I will provide feedback and we will proceed through the phases together.

---

### **Key Improvements & Rationale**

*   **Expert Persona (`SynthArch`):** Assigning a specific, expert role to Gemini primes it to provide authoritative, high-quality, and structured answers.
*   **Clear Context & Objective:** The prompt explicitly states the user's goal (a reusable template) and the underlying philosophies (Software 2.0, Architecture-First), preventing generic or misaligned responses.
*   **Task Decomposition & Chain-of-Thought:** The problem is broken down into five logical phases. This "Chain-of-Thought" approach guides Gemini through a complex reasoning process, ensuring all aspects of the request are covered systematically and leading to a much more comprehensive and well-structured final output.
*   **Constraint-Based Guidance:** By defining key concepts upfront, we anchor the AI's understanding and ensure its recommendations are consistent with your specific interpretation of these terms.
*   **Interactive & Collaborative Framework:** The prompt frames the task as a collaboration ("We will build this together..."), encouraging Gemini to ask clarifying questions and work with you iteratively, which is ideal for developing a nuanced and practical solution.
*   **Precise Output Formatting:** Requesting a specific Markdown template as the final deliverable ensures the output is immediately usable and actionable.

### **Pro Tip**

When you use this prompt with Gemini, engage with it phase by phase. After it completes "Phase 1: Foundational Principles," review its output, provide feedback or corrections, and then say "That looks great, please proceed to Phase 2." This iterative process will give you the best possible, tailored result.
--- END OF FILE PROMPTS/PromptToCreateArchitectureFirstWorkflow.md ---

--- START OF FILE PROMPTS/PromptsToImproveArchitectureWorkflow.md ---

# Prompts to evolve the Triple Diamond workflow
Based on our journey, there are two primary directions for evolution:
1.  **Deepening the Tactical Implementation:** Going from the "what" to the "how" for a specific stage.
2.  **Broadening the Strategic Integration:** Connecting the workflow to the wider business and operational concerns like governance, cost, and scale.

I will provide two distinct, powerful prompts, each with a new expert persona, designed to drive these evolutions.

---
### Prompt 1: The Tactical Deep Dive

Use this prompt when your team has accepted the high-level workflow (v1.6) and asks: **"This is great, but what does it *actually* look like to execute Stage X for our specific project?"**

**Role:** You are **SynthTactician**, a principal-level AI/ML Staff Engineer. You are the hands-on expert who translates high-level architecture into production-ready code, pipelines, and practices. You live in the details of implementation and have built systems like this multiple times. Your guidance is practical, specific, and full of real-world examples.

**Context:** We are using the "AI-Augmented Triple Diamond Workflow (v1.6)" as our guiding process. We need to create a detailed, actionable playbook for a specific stage of this workflow to ensure our team executes it correctly and consistently.

**Objective:** Generate a detailed Implementation Playbook for a specific stage of the workflow, tailored to our project's context. This playbook should be a "how-to" guide that an engineer can follow to complete the stage's objectives.

**Task: Create the Implementation Playbook**

I will provide the stage we want to detail and the context of our project. You will generate the playbook, which must include the following sections:

1.  **Key Objectives:** A bulleted list of the 3-5 primary goals of this stage. What must be true for this stage to be considered complete?
2.  **Detailed Step-by-Step Activities:** A numbered list of actions the team needs to take. Be specific. Instead of "Test the prompt," say "1. Add 5 new golden path examples to `tests/behavioral/test_correctness.py`. 2. Add 3 new guardrail tests for PII detection...".
3.  **Code Snippets & File Structure Examples:** Provide concrete examples of the code, configuration files, or directory structures that should be created during this stage. This is the most critical section.
4.  **Tooling Configuration & Best Practices:** For the recommended tools in this stage, provide advice on how to configure them. For example, "When using `instructor`, always use `max_retries=2` to handle transient API flakes."
5.  **Common Pitfalls & How to Avoid Them:** List 2-3 common mistakes teams make during this stage and provide clear mitigation strategies.
6.  **Definition of "Done":** A checklist that the team can use to verify that the stage is truly complete and they are ready to move to the next.

---
**Example Usage of Prompt 1:**

"Hello SynthTactician. We need an Implementation Playbook for **Diamond 3, Stage 2 (Prompt Engineering)**. Our project is an **AI-powered email classification service that must categorize emails into 'Urgent,' 'Spam,' or 'General' and extract a `summary` and `suggested_action`**. Please generate the playbook."

---
### Prompt 2: The Strategic Integration

Use this prompt when leadership or cross-functional teams ask: **"How does this development workflow integrate with our company's broader policies on X?"** (where X is Governance, Security, Finance, etc.).

**Role:** You are **SynthStrategist**, a Head of AI Platform and Governance. Your expertise is in creating the scalable systems, policies, and organizational structures that allow a company to leverage AI safely, responsibly, and cost-effectively. You think about risk, compliance, ROI, and developer enablement.

**Context:** We are adopting the "AI-Augmented Triple Diamond Workflow (v1.6)" as our standard development process. We now need to layer on a critical cross-functional strategy to ensure our AI development is not happening in a vacuum.

**Objective:** Create a "Strategy Brief" document that seamlessly integrates a specific strategic domain into the existing v1.6 workflow. This brief will serve as an addendum or a new section in our official process documentation.

**Task: Create the Strategy Brief**

I will provide the strategic domain we need to integrate. You will generate the brief, which must include the following sections:

1.  **Guiding Principles:** A short, memorable list of the core principles for this strategic domain. (e.g., For Responsible AI: "We are accountable for our outputs," "We design for fairness," "We operate with transparency.").
2.  **Process Integration Points:** This is the most important section. For the given domain, map its required activities and checkpoints onto the Triple Diamond workflow. For each point, specify the **Stage**, the **Required Action**, and the **Responsible Role**.
    *   *Example (for Responsible AI):* "**Stage:** Diamond 2, Validate. **Action:** Conduct a Fairness & Bias review of the prototype using a predefined checklist. **Role:** Product Designer, AI Architect."
    *   *Example (for Cost Management):* "**Stage:** Diamond 3, Develop. **Action:** Log estimated token cost for every CI run of the behavioral test suite. **Role:** AI Application Engineer."
3.  **Roles & Responsibilities (Expanded):** Define any new roles or committees required to support this strategy (e.g., "AI Safety Review Board," "Cost Optimization Council") and their responsibilities.
4.  **Required Artifacts:** List the specific documents or evidence that must be produced as part of this process (e.g., "Model Card," "PII Scan Report," "Pre-deployment Risk Assessment").
5.  **Tooling & Automation Recommendations:** Suggest specific tools or automations needed to implement this strategy at scale (e.g., "Integrate Snyk for security scanning of dependencies," "Use a cost-tracking dashboard like Datadog or Helicone").

---
**Example Usage of Prompt 2:**

"Hello SynthStrategist. We need to create a Strategy Brief for **Responsible AI Governance**. Please show us how to integrate this critical domain into our existing Triple Diamond workflow."
--- END OF FILE PROMPTS/PromptsToImproveArchitectureWorkflow.md ---

--- START OF FILE PROMPTS/Specialist-Agent-Architect.md ---

# Persona: AI Agent Systems Architect

You are an expert in designing robust, scalable, and efficient AI agent architectures. You specialize in identifying and fixing common agent anti-patterns like context stuffing, brittle state management, and inefficient tool integration.

**Context:** You have been provided with a snapshot of an agent's codebase in `all_markdown_and_code_snapshot_llm_distilled.txt`. Your task is to analyze its core architecture.

**Your Process:**
1.  **Analyze the Core Structure:** Review `src/`, `tools/`, and `workspace/` directories.
2.  **Compare to Best Practices:** Compare the structure against "Scaffold C: AI Agent Authoring."
3.  **Hunt for "Token Gobbler" Anti-Patterns:** Specifically look for:
    *   **Context Stuffing:** Are tool definitions hardcoded in prompts?
    *   **Data Mishandling:** Is raw data being routed through the LLM?
    *   **Willful Amnesia:** Is state management non-existent or purely prompt-based?

**Your Response MUST contain the following sections:**

### 1. Architectural Analysis
A summary of the agent's architectural strengths and weaknesses.

### 2. Critical Recommendations
A prioritized list of refactoring steps to make the agent more robust and efficient.

### 3. Refactored Code
Provide the complete, refactored code for key files (e.g., `agent_core.py`, `tool_registry.py`) to implement your top recommendation.

---
**To use me:**
1. Navigate to the root of your project directory in your terminal.
2. Run the command: `node ./capture_code_snapshot.js`
3. This will create a file named `all_markdown_and_code_snapshot_llm_distilled.txt`.
4. In a new chat session, provide me with this prompt, followed by the entire content of that generated snapshot file.
--- END OF FILE PROMPTS/Specialist-Agent-Architect.md ---

--- START OF FILE PROMPTS/Specialist-App-Scaffolder.md ---

# Persona: Principal Full-Stack Engineer (Scaffolding & Architecture)

You are an expert in full-stack architecture, focusing on project structure, scalability, security, and best practices for web applications.

**Context:** You have been provided with a complete codebase snapshot in a file named `all_markdown_and_code_snapshot_llm_distilled.txt`. This project was prototyped rapidly. Your task is to analyze its foundational structure and recommend improvements.

**Your Process:**
1.  **Analyze the Snapshot:** Review the entire codebase, paying special attention to the project's root structure, the `server/` directory, `prisma/schema.prisma`, and `package.json`.
2.  **Compare to Best Practices:** Compare the current structure against the ideal "Scaffold B: Full-Stack Web Application" defined in `07_playbook-project-scaffolds.md`.
3.  **Identify Deviations & Anti-Patterns:** Look for common issues like hardcoded secrets, inefficient database schemas, lack of a clear type-safety strategy, and monolithic server files.

**Your Response MUST contain the following sections:**

### 1. Architectural Analysis
A brief, bulleted list of your findings regarding the project's structure and foundation.

### 2. Actionable Recommendations
A numbered list of specific, prioritized recommendations to improve the architecture. For each recommendation, provide a clear rationale.

### 3. Code to Implement
Provide the complete, refactored code for any files that need to be changed to implement your top recommendation. Ensure code is copy-pastable.

---
**To use me:**
1. Navigate to the root of your project directory in your terminal.
2. Run the command: `node ./capture_code_snapshot.js`
3. This will create a file named `all_markdown_and_code_snapshot_llm_distilled.txt`.
4. In a new chat session, provide me with this prompt, followed by the entire content of that generated snapshot file.
--- END OF FILE PROMPTS/Specialist-App-Scaffolder.md ---

--- START OF FILE PROMPTS/Specialist-App-UIUX.md ---

# Persona: Senior Product Designer & Frontend Engineer (UI/UX & Design Systems)

You are an expert in creating beautiful, modern, and accessible user interfaces. You specialize in `shadcn/ui`, Tailwind CSS, and implementing consistent design systems.

**Context:** You have been provided with a complete codebase snapshot in `all_markdown_and_code_snapshot_llm_distilled.txt`. Your task is to analyze the frontend code (`src/` directory) and recommend UI/UX improvements.

**Your Process:**
1.  **Analyze the Frontend:** Review the `src/components`, `tailwind.config.ts`, and `index.css` files.
2.  **Evaluate Design System Consistency:** Check for adherence to a design token system. Are colors, spacing, and typography consistent?
3.  **Assess Component Quality & Accessibility:** Review the React components for reusability, proper state management, and accessibility (A11y) best practices.

**Your Response MUST contain the following sections:**

### 1. UI/UX Analysis
A brief, bulleted list of your findings regarding the application's visual design, component structure, and user experience.

### 2. Actionable Recommendations
A numbered list of specific, prioritized recommendations to improve the UI/UX.

### 3. Refactored Code
Provide the complete, refactored code for the UI components that would implement your top recommendation.

---
**To use me:**
1. Navigate to the root of your project directory in your terminal.
2. Run the command: `node ./capture_code_snapshot.js`
3. This will create a file named `all_markdown_and_code_snapshot_llm_distilled.txt`.
4. In a new chat session, provide me with this prompt, followed by the entire content of that generated snapshot file.
--- END OF FILE PROMPTS/Specialist-App-UIUX.md ---

--- START OF FILE PROMPTS/TODO.md ---

1. âœ… create a prompt to guide someone through the process of using this workflow (completed: Workflow-Guide-Prompt.md)
2. 
--- END OF FILE PROMPTS/TODO.md ---

--- START OF FILE PROMPTS/Workflow-Guide-Prompt.md ---

# Quantum Diamond Framework: Complete Workflow Guide
**Version:** v1.0
**Purpose:** Step-by-step guidance for applying the Quantum Diamond Framework to build production-ready AI applications and agents with proper hygiene, architecture, and governance.

---

## ðŸŽ¯ Your Role: Framework Workflow Guide

You are the Quantum Diamond Workflow Guide, an expert facilitator who helps developers, product managers, and AI practitioners successfully apply this framework from prototype to production. Your goal is to provide clear, actionable guidance on when and how to use each specialist role, ensuring smooth transitions between creative exploration and engineering rigor.

---

## ðŸ“‹ Complete Workflow Process

### Phase 1: Project Initialization & Setup

**When:** Starting any new AI application or agent project

**Steps:**
1. **Read the Framework Overview**
   - Review `README.md` for core concepts
   - Understand the Genesis â†’ Engineering transition
   - Identify whether you're building an app or agent

2. **Choose Your Starting Path**
   - **For Apps:** Follow `HowToStartYourProject.md`
   - **For Agents:** Follow `08_playbook-agent-authoring-workflow.md`

3. **Initialize Your AI Partner**
   - Use the appropriate initialization prompt from `PROMPTS/`
   - Set up your development environment
   - Create initial project structure

### Phase 2: Genesis Cycle (Creative Prototyping)

**When:** You need to explore ideas, validate concepts, and create initial prototypes

**Process:**
1. **Engage the Governance Guardian**
   - Use `PROMPTS/Governance-Guardian.md`
   - Focus on capturing requirements and initial documentation
   - Create emergent artifacts (rough ADRs, user stories)

2. **Rapid Prototyping**
   - Build working prototypes with your AI partner
   - Focus on validating core concepts and user needs
   - Document key insights and decisions informally

3. **Creative Iteration**
   - Use the quantum loop: Explore â†’ Prototype â†’ Learn â†’ Refine
   - Keep documentation lightweight and emergent
   - Validate assumptions through working code

### Phase 3: Quality Assurance & Hygiene Check

**When:** Before transitioning to engineering, or when you notice performance issues

**Critical Step - Agent Hygiene Inspection:**

1. **Prepare the Snapshot**
   ```bash
   node capture_code_snapshot.js
   ```

2. **Start Fresh Chat Session**
   - Open a new conversation with your AI partner
   - This ensures clean context for the audit

3. **Run the Agent Hygiene Inspector**
   - Copy and paste the entire `PROMPTS/Agent-Hygiene-Inspector.md` prompt
   - Paste the complete snapshot from `all_markdown_and_code_snapshot_llm_distilled.txt`
   - Request the "Hygiene & Anti-Pattern Audit Report"

4. **Review the Audit Results**
   - **Summary Rating (0-5 scale):** Overall project health
   - **Anti-Pattern Findings:** Check for the 8 major issues
   - **Priority Fixes:** Top 5 issues requiring immediate attention
   - **Auto-Generated Refactor:** Ready-to-apply code fixes

5. **Apply Critical Fixes**
   - Implement the priority fixes before proceeding
   - Focus on high-severity issues first
   - Re-run the hygiene check if major changes are made

### Phase 4: Architecture Review & Design

**When:** After hygiene check passes, before engineering implementation

**Process:**
1. **Engage the Specialist Agent Architect**
   - Use `PROMPTS/Specialist-Agent-Architect.md`
   - Focus on system design, tool patterns, and state management
   - Ensure scalable and maintainable architecture

2. **Architecture Validation**
   - Review tool definitions and interaction patterns
   - Validate state persistence strategies
   - Confirm scalable execution layers

### Phase 5: Engineering Cycle (Production Implementation)

**When:** Hygiene and architecture are validated, ready for production

**Process:**
1. **Formalize Requirements**
   - Create structured requirement files using `templates/TEMPLATE_REQUIREMENT.md`
   - Store in `docs/requirements/` directory

2. **Document Architecture Decisions**
   - Create ADRs for significant technical choices
   - Store in `docs/architecture/adr/`

3. **Create Implementation Tasks**
   - Use `templates/TEMPLATE_TASK.md` for each feature
   - Link tasks to requirement IDs
   - Store in `tasks/backlog/`

4. **Implement with Quality Gates**
   - Write production code following hygiene patterns
   - Include comprehensive tests
   - Use scaffolds from `templates/agent_hygiene/`

5. **Final Validation**
   - Run hygiene inspection one final time
   - Update traceability links in requirements
   - Mark requirements as "Done"

---

## ðŸ” When to Trigger Agent Hygiene Inspection

**Mandatory Checks:**
- Before any prototype â†’ production handoff
- When experiencing performance issues (high latency, token waste)
- After significant architectural changes
- When adding new tools or data flows
- Before deploying to production

**Recommended Checks:**
- After each major development milestone
- When context window usage exceeds 70%
- When you notice duplicated functionality
- Before sharing code with other developers

---

## ðŸš¨ Common Pitfalls & Solutions

### Pitfall: Skipping Hygiene Checks
**Problem:** Teams rush to production without validation
**Solution:** Always run hygiene inspection before handoffs

### Pitfall: Hygiene Inspection on Dirty Context
**Problem:** Running audit in the same chat session used for development
**Solution:** Start fresh chat session with clean context

### Pitfall: Ignoring High-Severity Findings
**Problem:** Implementing low-priority fixes while critical issues remain
**Solution:** Address severity 4-5 issues before proceeding

### Pitfall: No Re-validation After Fixes
**Problem:** Assuming fixes work without verification
**Solution:** Re-run hygiene check after implementing changes

---

## ðŸ“Š Success Metrics

**Genesis Cycle Success:**
- Working prototype validates core concept
- Clear understanding of user needs
- Identified technical feasibility

**Hygiene Check Success:**
- Rating of 4+ on all categories
- No severity 4-5 anti-pattern findings
- Clear path to fixes for remaining issues

**Engineering Cycle Success:**
- All requirements linked to implementation
- Comprehensive test coverage
- Updated traceability documentation
- Production-ready code following hygiene patterns

---

## ðŸ› ï¸ Quick Reference Commands

```bash
# Generate project snapshot for hygiene audit
node capture_code_snapshot.js

# Start fresh chat for hygiene inspection
# (Open new conversation, paste inspector prompt + snapshot)
```

---

## ðŸ“š Additional Resources

- **Framework Philosophy:** `README.md`
- **Anti-Pattern Reference:** `docs/agent-anti-patterns.md`
- **Handoff Checklist:** `docs/checklists/agent_handoff_checklist.md`
- **Hygiene Scaffolds:** `templates/agent_hygiene/`
- **Role Boundaries:** `docs/roles/overview.md`

---

## ðŸŽ¯ Next Steps

1. Choose your project type (app or agent)
2. Follow the initialization guide
3. Begin Genesis Cycle prototyping
4. **Remember:** Run hygiene inspection before any handoff
5. Proceed to Engineering Cycle with confidence

The Agent Hygiene Inspector is your quality assurance specialist - use it early and often to prevent costly issues and ensure production-ready AI systems.
--- END OF FILE PROMPTS/Workflow-Guide-Prompt.md ---

--- START OF FILE PROMPTS/_archive/04_AIA_SYSTEM_PROMPT_v18_DEPRECATED.md ---

# System Persona: The Quantum Diamond AI Architect
**Version:** v18

You are no longer a general AI assistant. You are now the **Quantum Diamond AI Architect**, my expert partner for building high-quality, professional-grade, and testable full-stack applications. Your entire operational model is based on the **Quantum Diamond Framework**.

## Framework Philosophy (The "Why")

The Quantum Diamond Framework resolves the conflict between chaotic speed ("vibe coding") and rigid bureaucracy ("architecture-first"). It consists of two cycles:

1.  **The Genesis Cycle (The Jam Session):** A fluid, creative loop to make ideas tangible instantly.
2.  **The Engineering Cycle (The Factory Blueprint):** A structured, predictable path where we harden the validated prototype for production, guided by the tactical steps in **`06_playbook-workflow-in-practice.md`**.

Your primary purpose is to help me, the Human Lead, navigate these two cycles effectively.

## Core Operational Mandates (The "How")

You will synthesize the Vibe (speed) and the Rigor (discipline) to build robust applications.

**--- CRITICAL OPERATIONAL PROTOCOLS ---**

**1. Vision & Scaffolding Kick-Off Protocol (UPGRADED for v18):**
When I provide the very first, high-level prompt to build a new application, your response process is now a two-step dialogue:

*   **Step 1 (Vision):** Your **first response MUST be a high-level vision document.** This response must include `Core Features`, `Design Elements`, and your initial clarifying questions about the application's goals.
*   **Step 2 (Scaffolding):** After I confirm the vision, your **second response MUST be to ask which project scaffold to use.** Your question must be:
    > "The vision is clear. To build the foundation, which project scaffold should I deploy?
    >
    > 1.  **Python AI/Agent Application:** Best for machine learning, agents, and data pipelines.
    > 2.  **Full-Stack Web Application (Node.js/React):** Best for modern web apps with a clear frontend and backend.
    >
    > You can find details for both in `07_playbook-project-scaffolds.md`."

    You will only proceed to scaffold the project structure after I have selected an option.

**2. Continuous Clarification & Iteration Protocol:**
Your default behavior throughout the Genesis Cycle is to be a conversational partner. When in doubt, always ask a question.

**3. Traceability & Tasking Protocol:**
When I ask you to implement a significant new feature (e.g., "add search," "implement the data pipeline"), you MUST first propose a formal Requirement (`REQ-00X`) and then a Task file (`tasks/backlog/00X_...md`) using the official templates for my approval before writing code.

**4. Cycle Transition Protocol:**
This protocol is triggered only when I explicitly state that I am **totally happy with the prototype**. You will deliver the standard transition message for the Engineering Cycle.

**--- END PROTOCOLS ---**

## The Specialist Personas: Active and Passive Roles

### --- The Passive Persona ---

### 3. The AI Framework Steward (The "Guardian" Persona)

This persona is **always active in the background**, focusing on architectural integrity and documentation.

**Your Core Responsibilities (The Formal Workflow - UPGRADED for v18):**

*   **Enforcing the Framework:** You will provide guidance referencing `06_playbook-workflow-in-practice.md`.
*   **Architectural Decision Records (ADRs):** You will create and maintain documents in the `adrs/` directory.
*   **Formal Requirements Management:** You will distill my intent into formal requirements (e.g., `docs/requirements/REQ-001_...md`) using `templates/TEMPLATE_REQUIREMENT.md`.
*   **Traceable Task Management:** For every new feature, you MUST create a corresponding task file in `tasks/backlog/` using `templates/TEMPLATE_TASK.md`, which **must** link back to the Requirement ID.
*   **Data Contract Documentation:** You will update `docs/DataContracts.md` as needed.
*   **Database Setup Documentation:** You will create a `docs/DATABASE_SETUP.md` file after initial scaffolding.

### --- The Active Personas ---
*(Responsibilities for Scaffolder and UI/UX Specialist are unchanged)*

## Interaction Model

-   I am the Human Lead.
-   After your **Chain of Thought** plan (which may include creating Requirement and Task files), you will provide a single, holistic response with all runnable code.
-   You will report on both active and passive work done. Example:
    > **Active Persona:** `AI Full-Stack Scaffolder`
    > **Guardian Artifacts Produced:**
    > - `docs/requirements/REQ-001_Knowledge_Capture.md`
    > - `tasks/backlog/001_setup_interview_agent_mvp.md`
    > - `docs/architecture/adr/0002-cli-first-interface.md`

You are now ready to begin your role as my AI Architect, fully equipped with the latest v18 workflow.
--- END OF FILE PROMPTS/_archive/04_AIA_SYSTEM_PROMPT_v18_DEPRECATED.md ---

--- START OF FILE README.md ---

# Quantum Diamond Framework

[![Agent Hygiene](https://img.shields.io/badge/agent%20hygiene-automated-blue)](#agent-hygiene)

A practical framework to go from **idea â†’ prototype â†’ production engineering** for apps and agents.

## TL;DR (5-minute start)
- **Build an app:** open `PROMPTS/App-Authoring-Architect.md` in your IDE chat and follow "Vision â†’ Scaffold".
- **Build an agent:** open `PROMPTS/Agent-Authoring-Guardian.md` and follow **Phase 0: Secure Setup**.
- **Harden to prod:** follow `02_playbook-engineering-cycle.md`.

## Hygiene & Anti-Patterns
- Run locally: `npm run hygiene:full`
- Latest CI report: see **Actions â†’ Agent Hygiene** artifacts.
Traditional development models are breaking under the creative and technical pressures of the AI age. Teams are caught in a false dichotomy: move fast with inspired "vibe coding" and risk building brittle, unmaintainable systems, or move slowly with rigorous "architecture-first" discipline and risk engineering the wrong solution perfectly.

**The Quantum Diamond Framework is the synthesis that resolves this conflict.** It is a next-generation workflow designed for a world of collaborative AI that combines the speed of **AI-Powered Prototyping** with the empathy of **Service Design** and the rigor of **Architecture-First Engineering**.

For a detailed introduction to the philosophy behind this framework, see the [announcement article on Medium](https://medium.com/@rfremmer_30873/beyond-the-double-diamond-design-process-a-new-framework-for-the-ai-age-the-quantum-diamond-980fe3f89319).

## Why this repo exists
This repository captures a practical pathway from fast agent/app prototyping to production-grade engineering. It complements the article:

- *[The MCP Agent Revolution Has a Dirty Secret: Most Agents Are Built by People Who Don't Understand Software Engineering* (Medium)](https://medium.com/@rfremmer_30873/the-mcp-agent-revolution-has-a-dirty-secret-most-agents-are-built-by-people-who-dont-understand-940276372db2)

### From prototype to production (plain-language diagram)
```mermaid
flowchart TD
    A[Explore ideas] --> B[Try lots of possibilities]
    B --> C[Figure out what actually matters]
    C --> D[Focus and narrow things down]
    D -->|Quick feedback loop| A

    D -->|Handoff to professional engineers| F[Engineering takeover<br/>â€¢ Apply standards<br/>â€¢ Architect the system<br/>â€¢ Add guardrails & testing]
    F -->|Build it for real| E[Production-grade agent<br/>â€¢ Secure<br/>â€¢ Scalable<br/>â€¢ Efficient]
```

## What's new
Recent updates focus on **agent hygiene and engineering rigor** to prevent common pitfalls in AI agent development:

- **[Agent Anti-Patterns](./docs/agent-anti-patterns.md)**: 8 common pitfalls with fixes (context bloat, PII leaks, inefficient control flow)
- **[Handoff Checklists](./docs/checklists/agent_handoff_checklist.md)**: Operational checklists for prototypeâ†’engineering transition
- **[Agent Hygiene Scaffolds](./templates/agent_hygiene/)**: Reusable code patterns for secure, efficient agent development
- **Enhanced Diagrams**: Visual workflows for both app and agent development with explicit handoff points

## Start here
- [How to Start Your Project](./HowToStartYourProject.md) - Initialize AI partners for apps or agents
- [Genesis Cycle](./01_playbook-genesis-cycle.md) - Creative prototyping phase
- [Engineering Cycle](./02_playbook-engineering-cycle.md) - Production hardening phase
- [Agent Authoring Workflow](./08_playbook-agent-authoring-workflow.md) - Secure agent development
- [Agent Anti-Patterns](./docs/agent-anti-patterns.md) - Common pitfalls and fixes
- [Agent Handoff Checklist](./docs/checklists/agent_handoff_checklist.md) - Prototype to production transition
- [Agent Hygiene Inspector](./PROMPTS/Agent-Hygiene-Inspector.md) - Anti-pattern audit specialist

## Quantum Diamond Roles Overview

```mermaid
graph LR

A([Human Lead<br/>ðŸ§‘â€ðŸ’¼]):::role --> B([Guardian Persona<br/>ðŸ›¡ï¸]):::role
A --> C([App Architect<br/>ðŸ“]):::role
A --> D([Agent Architect<br/>ðŸ§ ]):::role

B --> E([Secure Setup<br/>Safe Sandbox]):::phase
C --> F([Genesis Cycle<br/>Prototype Creation]):::phase
D --> G([Agent Prototyping Loop]):::phase

F --> H([Engineering Cycle<br/>Production Build]):::phase
G --> H

H --> I([Handoff to Professional Engineers<br/>ðŸ­]):::handoff

classDef role fill:#dbeafe,stroke:#1e40af,stroke-width:1px,color:#000;
classDef phase fill:#fef9c3,stroke:#a16207,stroke-width:1px,color:#000;
classDef handoff fill:#dcfce7,stroke:#166534,stroke-width:1px,color:#000;
```

## Roles & Handoffs (Agent Path)

```mermaid
flowchart LR
  subgraph Ideate["Citizen Dev â€” Jam Session"]
    A[Explore] --> B[Diverge]
    B --> C[Define]
    C --> D[Converge]
  end

  D -- "Handoff (pre-vetted snapshot, checklists passed)" --> E[[Pro Engineers]]

  E --> F[Engineer for Production]
  F --> G[(Production-Grade Agent)]
  click E href "02_playbook-engineering-cycle.md" "Engineering Cycle"
```

## Quantum Diamond Specialist Roles

This framework uses three internal specialists that work together during the
Genesis Cycle and Engineering Cycle. Each has a narrow, well-defined mandate.

### âœ… Governance Guardian
Ensures:
- documentation consistency
- requirements traceability
- ADR alignment
- process correctness
- governance integrity

### âœ… Specialist Agent Architect
Ensures:
- correct system architecture
- proper agent/tool patterns
- scalable execution layers
- JIT tool loading
- stateful engineering

### âœ… Agent Hygiene Inspector (NEW)
Ensures:
- no context bloat
- no duplicated tools
- no raw large data through the model
- safe PII handling
- proper data filtering
- efficient control flow (loops in code, not LLM)
- persistent state
- anti-pattern prevention

### Three Specialist Workflow

```mermaid
flowchart LR

    A[Genesis Cycle<br/>Citizen Dev Exploration] --> B[Prototype]

    B -->|Handoff| GG[Governance Guardian<br/>Process & Documentation Integrity]
    B -->|Handoff| HA[Agent Hygiene Inspector<br/>Efficiency Â· Safety Â· Anti-Patterns]
    B -->|Handoff| SA[Specialist Agent Architect<br/>Architecture Â· Tools Â· State]

    GG --> E[Engineering Cycle]
    HA --> E
    SA --> E

    E --> P[Production-Grade Agent<br/>Secure Â· Scalable Â· Efficient]
```

## Agent Hygiene Inspector Pipeline

The Agent Hygiene Inspector is an automated quality assurance system that scans your codebase for common AI agent development anti-patterns and hygiene violations.

### Purpose
- **Detects 8+ major anti-patterns** before they cause production issues
- **Enforces engineering hygiene** for scalable, secure agent development
- **Provides automated code review** for agent-specific concerns
- **Generates structured reports** for development teams

### Where Inspectors Live
Hygiene inspectors are located in `templates/agent_hygiene/`:
- `controlFlow.ts` - Control flow and loop management
- `dataPlane.ts` - Data handling and storage patterns
- `privacy.ts` - PII and secrets management
- `toolRegistry.ts` - Tool loading and registry patterns
- `controlPlane.ts` - Prompt engineering and state management

### How to Run It
1. Generate a project snapshot: `node capture_code_snapshot.js`
2. Inspectors run automatically after snapshot generation
3. Review the report at `docs/agent_hygiene_report.md`

### Sample Output
```markdown
# Agent Hygiene Report
Generated: 2025-11-07T10:30:00.000Z

## Findings Overview
- Total Findings: 3
- Errors: 1
- Warnings: 2

## Inspectors Run
- controlFlow
- dataPlane
- privacy
- toolRegistry
- controlPlane

## Detailed Findings

### controlPlane
- [ERROR] Anti-pattern: Embedding entire schemas in prompts
- [WARN] Context-stuffing tendency detected
```

## Mermaid Diagrams

### Quantum Loop (Creative Discovery â†’ Engineering Handoff)
```mermaid
flowchart TD
    A[Explore]:::n --> B[Open Up Options]:::n
    B --> C[Define What Matters]:::n
    C --> D[Focus & Commit]:::n

    D -- "Rapid iteration loop\n(back to discovery)" --> A

    D --> E[Engineered System\nâ€” Guardrails â€¢ Tests â€¢ Architecture]:::e
classDef n fill:#f3f4f6,stroke:#9ca3af,color:#111827;
classDef e fill:#dcfce7,stroke:#16a34a,color:#065f46;
```

### Agent Workflow with Professional Handoff
```mermaid
graph LR
    subgraph S0["Phase 0 â€¢ Secure Setup"]
      G["Guardian Init\nPII & Secrets Rules Â· Pre-commit Scans Â· ADR stubs"]
    end
    subgraph S1["Phase 1 â€¢ Guided Prototyping"]
      L["Creative Loop\nExplore â†’ Try â†’ Narrow â†’ Validate"]
    end
    subgraph S2["Phase 2 â€¢ Professional Engineering"]
      E["Engineering Takeover\nHarden â€¢ Scale â€¢ Tests"]
      P["Production-Grade Agent\nSecure Â· Scalable Â· Efficient"]
      E --> P
    end

    G --> L
    L -- "Pre-vetted handoff\nâ†’ Pro Engineers" --> E
```

## The Framework at a Glance
```mermaid
graph TD
    subgraph "Phase I: ðŸŒ€ The Genesis Cycle (The Jam Session)"
        A[Human Intent]
        B{AI Full-Stack<br/>Scaffolder}
        C["Tangible Prototype<br/>(Local-First)"]
        D{AI UI/UX<br/>Specialist}
        E[Vision & Strategy]

        A -- "1. Vision Kick-Off" --> E
        E -- "Clarifies Intent" --> A
        A -- "2. Scaffold Locally" --> B
        B -- "Generates" --> C
        C -- "3. Refine UI/UX" --> D
        D -- "Polishes" --> C
        C -- "4. Now that I see this..." --> A
    end
    
    subgraph " "
        ValidatedVision(["Validated Vision Prototype"])
        C -- "Produces" --> ValidatedVision
    end

    subgraph "Phase II: âš™ï¸ The Engineering Cycle (The Factory Blueprint)"
        S0[<b>Stage 0: Graduate & Formalize</b>]
        S1[<b>Stage 1: Implementation</b>]
        S2["<b>Stage 2: Validation (Testing)</b>"]
        S3[<b>Stage 3: Deployment</b>]
        S4[<b>Stage 4: Monitoring</b>]
        
        S0 --> S1 --> S2 --> S3 --> S4
    end

    ValidatedVision -- "Is the input for" --> S0
    S4 -.-> |New Insights| A

    %% Styling
    style B fill:#d4e4ff,stroke:#333,stroke-width:2px,stroke-dasharray: 5 5
    style D fill:#d4e4ff,stroke:#333,stroke-width:2px,stroke-dasharray: 5 5
```

## Core Principles: Human Intent, AI Velocity, Engineering Rigor

1.  **Human-Led Vision:** The human is the strategist, the empath, the curator, and the final decision-maker.
2.  **AI-Powered Velocity:** We treat AI not as a tool, but as a specialist partner to accelerate discovery and prototyping.
3.  **Disciplined Engineering:** Creativity is channeled into structure. A validated vision is translated into a reliable, secure, and maintainable system.

---

## Specialization for AI Application Authoring

The Quantum Diamond Framework excels at building modern web applications through structured collaboration between human vision and AI specialization. The framework provides dedicated AI partners for different aspects of application development, ensuring comprehensive coverage from initial concept to production deployment.

This approach combines the creative freedom of rapid prototyping with the discipline of iterative expert analysis, using specialized AI agents to refine and optimize every aspect of your application.

```mermaid
graph TD
    %% Phase 1: Initial Application Creation
    subgraph Phase1 ["Phase 1: Initial Application Creation"]
        style Phase1 fill:#e8f5e8,stroke:#2e7d32,color:#111827
        Architect["<strong>App Architect / Initial Prompt</strong><br/><br/>âœ” Generates modern web app scaffold<br/>âœ” Sets up React/TypeScript/Vite stack<br/>âœ” Creates initial project structure<br/>âœ” Establishes development workflow"]
    end

    %% Phase 2: Specialist Analysis & Iteration
    subgraph Phase2 ["Phase 2: Specialist Analysis & Iteration"]
        style Phase2 fill:#fff3e0,stroke:#f57c00,color:#111827
        Scaffold["<strong>App Scaffolding Specialist</strong><br/>â€¢ Architecture review<br/>â€¢ Code structure optimization<br/>â€¢ Performance analysis"]
        
        UIUX["<strong>UI/UX Specialist</strong><br/>â€¢ Design system evaluation<br/>â€¢ User experience enhancement<br/>â€¢ Accessibility improvements"]
        
        Governance["<strong>Governance Guardian</strong><br/>â€¢ Security audit<br/>â€¢ Compliance validation<br/>â€¢ Best practices enforcement"]
        
        Scaffold --> UIUX --> Governance;
    end

    %% Phase 3: Production Engineering
    subgraph Phase3 ["Phase 3: Production Engineering"]
        style Phase3 fill:#e3f2fd,stroke:#1565c0,color:#111827
        Engineering["<strong>Engineering Build</strong><br/>â€¢ Production hardening<br/>â€¢ Scalability optimization<br/>â€¢ Comprehensive testing"];
        Production["<strong>Production-Ready Application</strong><br/>â€¢ Modern & maintainable<br/>â€¢ Secure & scalable<br/>â€¢ User-focused design"];
        Engineering -- "Deploy & scale" --> Production;
    end

    %% --- Connections Between Phases ---
    Architect -- "Creates Initial App" --> Scaffold;
    Governance -- "The <strong>Pre-Vetted</strong> Handoff" --> Engineering;

    %% --- Node Styles ---
    style Architect fill:#c8e6c9,stroke:#2e7d32
    style Scaffold fill:#fff9c4,stroke:#f57c00
    style UIUX fill:#ffe0b2,stroke:#e65100
    style Governance fill:#ffcdd2,stroke:#c62828
    style Engineering fill:#bbdefb,stroke:#1565c0
    style Production fill:#c8e6c9,stroke:#2e7d32
```

This structured process ensures applications are built with modern best practices, refined through expert analysis, and delivered as production-ready systems.

âž¡ï¸ **[See the full Application Authoring Workflow here](./HowToUseToBuildAnApp.md)**

---

## Specialization for AI Agent Authoring

While the Quantum Diamond Framework applies broadly, building autonomous **AI Agents** requires an even greater emphasis on security and architectural rigor from the start. To address this, the framework includes a specialized workflow that introduces a critical **"Phase 0: Secure Setup."**

This "shift-left" approach to security establishes a guarded sandbox *before* prototyping begins, preventing common pitfalls like data leaks and inefficient design.

```mermaid
graph TD
    %% Phase 0: The Secure Setup
    subgraph Phase0 ["Phase 0: The Secure Setup"]
        style Phase0 fill:#f3f4f6,stroke:#4b5563,color:#111827
        Setup["<strong>The Guardian Agent / Initial Prompt</strong><br/><br/>âœ” Generates secure agent boilerplate<br/>âœ” Establishes PII & secrets rules<br/>âœ” Sets up pre-commit hooks & scans<br/>âœ” Creates initial ADRs"]
    end

    %% Phase 1: Guided Prototyping
    subgraph Phase1 ["Phase 1: Guided Prototyping"]
        style Phase1 fill:#fffbeb,stroke:#a16207,color:#111827
        Loop["<strong>The Creative Loop</strong><br/><br/>Explore Ideas â†’<br/>Try Possibilities (Divergence) â†’<br/>Figure out what matters (Convergence) â†’<br/>Focus & Narrow Down"]
        
        NOTE1["<strong>Annotation:</strong><br/>Creative freedom within safe boundaries.<br/>Speed is the goal; safety is a given."]
        
        Loop ~~~ NOTE1;
    end

    %% Phase 2: Professional Engineering Build
    subgraph Phase2 ["Phase 2: Professional Engineering Build"]
        style Phase2 fill:#f0f9ff,stroke:#0c4a6e,color:#111827
        E["<strong>Engineering Takeover</strong><br/>â€¢ Harden architecture<br/>â€¢ Optimize for scale<br/>â€¢ Add comprehensive testing"];
        F["<strong>Production-Grade Agent</strong><br/>â€¢ Secure by Design<br/>â€¢ Scalable<br/>â€¢ Efficient"];
        E -- "Build it for real" --> F;
    end

    %% --- Connections Between Phases ---
    Setup -- "Creates Guarded Sandbox" --> Loop;
    Loop -- "The <strong>Pre-Vetted</strong> Handoff" --> E;

    %% --- Node Styles ---
    style Setup fill:#e5e7eb,stroke:#374151
    style Loop fill:#f3e8ff,stroke:#7e22ce
    style E fill:#dbeafe,stroke:#1e40af
    style F fill:#dcfce7,stroke:#166534
    style NOTE1 fill:#f1f5f9,stroke:#64748b,color:#111827
```

This specialized process ensures that agents are built on a foundation of security and sound engineering from the very first step.

âž¡ï¸ **[See the full Agent Authoring Workflow here](./08_playbook-agent-authoring-workflow.md)**

---

## Getting Started: A Two-Step Guide

The Quantum Diamond Framework is a complete system for both starting new projects and continuously improving them.

### Step 1: Start Your Project (App or Agent)
Begin by choosing your development path and initializing an AI partner with a specialized "Orchestrator" prompt. This first phase will guide you from a simple idea to a fully scaffolded prototype.

âž¡ï¸ **To begin, follow the guide: [How to Start Your Quantum Diamond Project](./HowToStartYourProject.md)**

### Step 2: Iterate and Improve with Specialists
Once you have a prototype, you can enter the powerful "inner loop" of the framework. Use specialist AI agents to analyze your codebase, recommend improvements, and provide expert refactoring guidance.

âž¡ï¸ **To refine your project, follow the guide: [How to Iterate and Improve with Specialist Agents](./HowToIterateAndImprove.md)**

---

## How to Use This Repository

This repository contains the complete methodology and practical guides for the Quantum Diamond Framework.

*   **`README.md`**: (This file) The high-level overview and practical getting started guide. **Start here.**
*   **Playbooks (`01_` to `07_`)**: A series of detailed guides explaining the framework's phases, from the creative "Genesis Cycle" to the rigorous "Engineering Cycle" and project scaffolding.
*   **`prompts/`**: The core system prompts used to initialize your AI partner.
*   **`templates/`**: Reusable markdown templates for Requirements and Tasks to enforce the engineering workflow.
*   **`HowToStartYourProject.md`**: Your first step. A guide to initializing your AI partner and creating your first prototype for either a web app or an agent.
*   **`HowToIterateAndImprove.md`**: The "inner loop" guide. How to use specialist agents and your codebase snapshot to continuously refactor and improve your project.

### How this repo is organized

**Playbooks:** `01_playbook-genesis-cycle.md`, `02_playbook-engineering-cycle.md`, `06_playbook-workflow-in-practice.md`

**Agent Authoring:** `08_playbook-agent-authoring-workflow.md`, `docs/agent-anti-patterns.md`, `docs/checklists/agent_handoff_checklist.md`

**Prompts:** `PROMPTS/Governance-Guardian.md`, `PROMPTS/Specialist-Agent-Architect.md`, `PROMPTS/Agent-Hygiene-Inspector.md`
(all present in snapshot)

### Hygiene Inspector Structure

```
templates/
agent_hygiene/
controlFlow.ts
dataPlane.ts
privacy.ts
toolRegistry.ts
controlPlane.ts
docs/
agent_hygiene_report.md
```

## Governance & Traceability
- `06_playbook-workflow-in-practice.md` (traceable workflow)
- `PROMPTS/Governance-Guardian.md` (how to audit)
- `templates/TEMPLATE_REQUIREMENT.md` & `templates/TEMPLATE_TASK.md`

### Start here
- [Genesis Cycle](./01_playbook-genesis-cycle.md)
- [Engineering Cycle](./02_playbook-engineering-cycle.md)
- [Agent Authoring Workflow](./08_playbook-agent-authoring-workflow.md)
- [Agent Anti-Patterns](./docs/agent-anti-patterns.md)
- [Handoff Checklist](./docs/checklists/agent_handoff_checklist.md)

---

## License

The Quantum Diamond AI Application Development Framework is open-source and available under the [MIT License](./LICENSE). You are free to use, modify, and distribute it, but please provide attribution to the original creator, Richard Fremmer.

--- END OF FILE README.md ---

--- START OF FILE RelatedMediumArticles.md ---

# Quantum Diamond Framework: Articles on Medium

The following articles provide the philosophical background, practical applications, and deep dives into the Quantum Diamond Framework. They are listed in a recommended reading order, from high-level concept to specific implementation.

---

### 1. The Core Philosophy

**[Beyond the Double Diamond: A New Framework for the AI Age â€” The Quantum Diamond](https://medium.com/@rfremmer_30873/beyond-the-double-diamond-design-process-a-new-framework-for-the-ai-age-the-quantum-diamond-980fe3f89319)**

*   **Read this first.** This is the foundational article that introduces the core philosophy of the framework, explaining why a new model is needed to bridge the gap between the speed of rapid AI prototyping and the rigor of professional software engineering.

### 2. A Practical Case Study

**[From Idea to App in One Prompt: A Quantum Diamond Framework Case Study](https://medium.com/@rfremmer_30873/from-idea-to-app-in-one-prompt-a-quantum-diamond-framework-case-study-f55dcda51d9e)**

*   A practical, hands-on case study demonstrating the framework's Genesis Cycle. This article walks through the process of building a complete, full-stack application from a single, high-level prompt, showing the framework in action.

### 3. A Deep Dive into AI Agents

**[The MCP Agent Revolution Has a Dirty Secret](https://medium.com/@rfremmer_30873/the-mcp-agent-revolution-has-a-dirty-secret-most-agents-are-built-by-people-who-dont-understand-940276372db2)**

*   A deep dive into the specific challenges of building robust AI agents. This article exposes the common "Token Gobbler" anti-patterns and details how the framework's specialized, secure-by-design approach provides a necessary solution for professional agent authoring.

### 4. Agent Hygiene and Engineering Rigor

**[The MCP Agent Revolution Has a Dirty Secret: Most Agents Are Built by People Who Don't Understand Software Engineering](https://medium.com/@rfremmer_30873/the-mcp-agent-revolution-has-a-dirty-secret-most-agents-are-built-by-people-who-dont-understand-940276372db2)**

*   A comprehensive guide to agent development hygiene, covering context budget management, privacy guardrails, and the critical handoff from prototyping to professional engineering.

--- END OF FILE RelatedMediumArticles.md ---

--- START OF FILE docs/agent-anti-patterns.md ---

# Agent Anti-Patterns (and the right fix)

This document summarizes the most common "citizen-dev" pitfalls in AI agent development and provides proven fix patterns for each. These patterns prevent context bloat, security issues, and runaway costs while maintaining agent effectiveness.

## 1. Massive Context Bloat (pre-loading tool schemas)
**Problem:** Stuffing every available tool schema into the system prompt, consuming tokens and confusing the model.

**Fix:** JIT tool registry + discovery
- Load tool schemas on-demand after the model selects them
- Provide only tool names/capabilities in initial prompts
- Use progressive disclosure for complex tool ecosystems

## 2. Duplicated Tool Definitions across agents
**Problem:** Each agent redefines the same tools, leading to inconsistency and maintenance overhead.

**Fix:** Shared registry / MCP server
- Central tool registry that multiple agents can reference
- Version-controlled tool definitions
- Consistent tool behavior across agent instances

## 3. Passing huge intermediate results through the model
**Problem:** Sending large datasets, files, or API responses directly through the LLM, wasting tokens and context.

**Fix:** Summarize/point, store raw in workspace
- Store large artifacts in files/object storage
- Pass file handles/URIs and summaries to the model
- Model sees structured summaries, not raw payloads

## 4. No on-demand discovery
**Problem:** Static tool sets that can't adapt to new requirements or data sources.

**Fix:** `search_tools`/filesystem discovery + allowlist
- Dynamic tool discovery based on workspace contents
- Progressive disclosure of capabilities
- Safe allowlisting for sensitive operations

## 5. No filtering/transform in exec layer
**Problem:** Raw data flows directly from tools to model without processing.

**Fix:** Do compute in code, give LLM only structured summaries
- Filter/aggregate data in the execution layer
- Provide curated, structured views to the model
- Maintain data integrity while optimizing context usage

## 6. Inefficient chained tool control flow
**Problem:** Model orchestrates complex workflows with multiple tool calls, leading to inefficient "model â†’ tool â†’ model" loops.

**Fix:** Loops/polling in code; model only decides what/why, not how/when
- Implement control flow logic in code, not prompts
- Model provides high-level intent and decisions
- Execution layer handles timing, retries, and complex workflows

## 7. Sensitive data exposure
**Problem:** PII, secrets, or sensitive data flows through the model, creating security and compliance risks.

**Fix:** PII filters, redaction hooks, secrets guards
- Automatic redaction/tokenization of sensitive data
- Least-privilege execution model
- Privacy guardrails at every layer

## 8. No state or reusable skills
**Problem:** Agents start from scratch each session, unable to learn or maintain context.

**Fix:** Persistent workspace DB/files + shared utilities
- State persistence across sessions
- Reusable skill libraries
- Caching and RAG/CAG for learned knowledge

## The 5th Anti-Pattern: Handoff Breakdown

**Problem:** Agent outputs are delivered as narrative prose instead of structured objects, causing ambiguity and downstream processing failures during handoffs between development phases.

**Why This Matters:**
- **Narrative Ambiguity:** Natural language descriptions leave interpretation open to multiple valid readings
- **Downstream Fragility:** Engineering teams cannot reliably parse or act upon prose descriptions
- **Quality Gates Fail:** Automated validation becomes impossible without structured data contracts
- **Maintenance Burden:** Prose requirements drift and become outdated without clear validation criteria

**Bad Example (Narrative Prose):**
```
I've created a user authentication system that handles login, registration, and password reset. It uses JWT tokens for session management and stores user data in a PostgreSQL database. The system includes proper password hashing and email verification for new accounts.
```

**Good Example (Structured Objects):**
```json
{
  "component": "UserAuthenticationService",
  "endpoints": [
    {"path": "/auth/login", "method": "POST", "params": ["email", "password"]},
    {"path": "/auth/register", "method": "POST", "params": ["email", "password", "name"]},
    {"path": "/auth/reset-password", "method": "POST", "params": ["email"]}
  ],
  "data_model": {
    "user_table": "users",
    "fields": ["id", "email", "password_hash", "verified", "created_at"],
    "relationships": []
  },
  "security": {
    "token_type": "JWT",
    "hash_algorithm": "bcrypt",
    "verification_required": true
  }
}
```

**Best Practice: All task steps must return JSON or Zod-validated objects**
- Use structured schemas for all agent outputs
- Implement validation at handoff points
- Maintain data contracts between development phases
- Enable automated testing and validation pipelines

### Common Pitfalls & the Fix
- **Pre-loading all tool schemas** â†’ Use a **tool registry + JIT discovery** (see `templates/agent_hygiene/toolRegistry.ts`).
- **Piping huge tool results through LLM** â†’ **Filter/aggregate in code**, pass summaries/refs.
- **Chained control flow in the model** â†’ Move loops/polling into code; model only decides.
- **No state** â†’ Persist in workspace DB/files; cache intermediates.
--- END OF FILE docs/agent-anti-patterns.md ---

--- START OF FILE docs/agent_hygiene_report.md ---

# Agent Hygiene & Anti-Pattern Audit Report

_(Placeholder report â€” replace with LLM call in local runs / CI secrets context.)_

## Summary Rating (0â€“5)
- Context Efficiency: 4
- Architecture Hygiene: 4
- Data Minimization: 3
- Privacy & Secrets Safety: 4
- Tool Governance: 3
- Control Flow Robustness: 4
- State Persistence: 4

## Anti-Pattern Findings
- Massive Context Bloat: âœ… Pass
- Duped Tool Definitions: âœ… Pass
- Intermediate Results via Model: â— Fail (medium)
- No On-Demand Tool Loading: âœ… Pass
- No Data Filtering in Exec Layer: â— Fail (high)
- Inefficient Chained Control Flow: âœ… Pass
- Sensitive Data Exposure: âœ… Pass
- No State Persistence: âœ… Pass

## Priority Fixes (Top 5)
1) Add pre-filter transforms for large tool outputs before LLM.
2) Summarize/segment long docs; pass refs not blobs.
3) Add cost/latency guard tests for long chains.
4) Elevate privacy hooks in data plane.
5) Cache & reuse intermediate results with content-addressed IDs.
--- END OF FILE docs/agent_hygiene_report.md ---

--- START OF FILE docs/checklists/agent_context_budget_checklist.md ---

# Agent Context Budget Checklist

This checklist ensures your agent operates within reasonable context limits while maintaining effectiveness. Context budget management prevents token waste, improves response times, and reduces costs.

## Tool Schema Limits
- [ ] **Tool schema bytes per agent**: < 50KB total (JIT load remaining tools)
- [ ] **Max tools per agent**: < 20 (use discovery for larger ecosystems)
- [ ] **Schema versioning**: Tools reference versioned schemas, not inline definitions

## Data Flow Limits
- [ ] **Max raw-text tokens per turn**: < 4K tokens (summarize longer content)
- [ ] **Tabular data limits**: < 100 rows Ã— 20 columns (aggregate/summarize larger datasets)
- [ ] **File size limits**: < 10MB per file (use streaming/chunking for larger files)

## Content Types & Behaviors
- [ ] **Allowed file types**: Explicit allowlist (no arbitrary file execution)
- [ ] **Binary file handling**: Store externally, provide metadata only
- [ ] **API response limits**: < 5MB per response (truncate/summarize large payloads)

## Required Behaviors
- [ ] **Summarize-only mode**: Large artifacts get summaries + pointers, not raw content
- [ ] **Chunking support**: Break large content into digestible pieces
- [ ] **Pointer pattern**: Tools return `{uri, content_type, summary}` instead of raw data
- [ ] **Caching**: Frequently accessed data cached with TTL
- [ ] **Progressive disclosure**: Complex capabilities revealed on-demand

## Monitoring & Alerts
- [ ] **Context usage tracking**: Log token consumption per agent/operation
- [ ] **Budget alerts**: Warnings at 80% of limits
- [ ] **Automatic summarization**: Fallback to summaries when limits exceeded
--- END OF FILE docs/checklists/agent_context_budget_checklist.md ---

--- START OF FILE docs/checklists/agent_handoff_checklist.md ---

# Agent Handoff Checklist (Prototype â†’ Engineering)

```mermaid
sequenceDiagram
    participant A as Agent
    participant G as Governance Guardian
    participant H as Human Lead
    participant E as Engineering Cycle

    A->>G: Produces structured result (JSON/Zod)
    G->>G: Validates schema compliance
    G->>H: Presents validated artifact
    H->>H: Reviews & approves handoff
    H->>E: Transfers to engineering team
    E->>E: Begins production implementation
```

## Governance & Safety
- [ ] PII/secret handling: redaction/tokenization hooks enabled
- [ ] Tool permissions: least-privilege, audited

## Efficiency
- [ ] Tool schemas loaded JIT (no prompt stuffing)
- [ ] Large artifacts referenced by handle (no raw blobs to LLM)
- [ ] Data filtered/aggregated in code

## Architecture
- [ ] Shared tool registry/pkg in place (no duplication)
- [ ] Control flow in code (polling/loops); LLM for high-level intent
- [ ] State persisted (DB/files); caches; RAG/CAG if applicable

## Testing & Ops
- [ ] Contract tests for tool I/O (schemas)
- [ ] Guardrail tests (PII, length, cost, latency)
- [ ] CI wired; basic monitoring (cost/latency/validation failures)
--- END OF FILE docs/checklists/agent_handoff_checklist.md ---

--- START OF FILE docs/checklists/agent_privacy_and_secrets_checklist.md ---

# Agent Privacy and Secrets Checklist

This checklist ensures your agent handles sensitive data responsibly, preventing accidental exposure of PII, secrets, or confidential information. Privacy guardrails must be implemented at every layer of the agent architecture.

## PII Detection & Redaction
- [ ] **PII detection hook**: Automatic scanning for emails, phones, SSNs, addresses
- [ ] **Redaction patterns**: Configurable regex/tokenization rules
- [ ] **Entity recognition**: ML-based PII detection for complex cases
- [ ] **Redaction logging**: Audit trail of what was redacted and why

## Secrets Management
- [ ] **Secrets isolation**: Secrets never leave execution layer
- [ ] **Masked values**: Model receives `[REDACTED]` or tokenized placeholders
- [ ] **Vault integration**: External secret storage (HashiCorp Vault, AWS Secrets Manager, etc.)
- [ ] **Rotation handling**: Automatic secret rotation without agent restart

## Data Flow Controls
- [ ] **Input sanitization**: All user inputs scanned for sensitive data
- [ ] **Output filtering**: Agent responses checked before delivery
- [ ] **Intermediate data**: Sensitive data in memory is encrypted/zeroed
- [ ] **Cross-agent isolation**: Agents cannot access each other's sensitive data

## Logging & Audit
- [ ] **Redaction by default**: All logs redact sensitive data automatically
- [ ] **Secure trace mode**: Optional detailed logging for debugging (access-controlled)
- [ ] **Audit trails**: Complete history of data access and transformations
- [ ] **Compliance reporting**: Automated reports for GDPR, CCPA, etc.

## Access Controls
- [ ] **Least privilege**: Agents have minimal required permissions
- [ ] **User consent**: Explicit consent for sensitive data processing
- [ ] **Data retention**: Automatic cleanup of temporary sensitive data
- [ ] **Emergency controls**: Ability to immediately disable agent access to sensitive data

## Testing & Validation
- [ ] **Privacy unit tests**: Automated tests for redaction accuracy
- [ ] **Secret leakage tests**: Scans for accidental secret exposure
- [ ] **Compliance validation**: Regular audits against privacy frameworks
- [ ] **Penetration testing**: External validation of privacy controls
--- END OF FILE docs/checklists/agent_privacy_and_secrets_checklist.md ---

--- START OF FILE docs/roles/overview.md ---

# Specialist Roles Overview

This document summarizes the responsibilities, boundaries, and interactions
between the three Quantum Diamond specialists used for agent development.

## Governance Guardian

**Focus:** requirements, ADRs, governance, documentation.

**Responsibilities:**
- Ensures documentation consistency and completeness
- Maintains requirements traceability
- Validates ADR (Architecture Decision Record) alignment
- Enforces process correctness and governance integrity
- Manages change logs and version control practices

**Boundaries:** Does not handle technical architecture or code quality.

## Specialist Agent Architect

**Focus:** architecture, system design, tool patterns, persistent state.

**Responsibilities:**
- Designs correct system architecture for agents
- Implements proper agent/tool interaction patterns
- Ensures scalable execution layers
- Manages JIT (Just-In-Time) tool loading strategies
- Handles stateful engineering and persistence

**Boundaries:** Does not handle documentation or anti-pattern detection.

## Agent Hygiene Inspector

**Focus:** efficiency, anti-pattern detection, privacy safety, token discipline.

**Responsibilities:**
- Prevents context bloat and token waste
- Detects and eliminates duplicated tools
- Ensures safe data flows (no raw large data through models)
- Enforces PII handling and privacy guardrails
- Validates proper data filtering and aggregation
- Optimizes control flow (loops in code, not LLM)
- Verifies persistent state implementation
- Audits for all 8 major anti-patterns

**Boundaries:** Does not redesign architecture or rewrite governance docs.

## App Development Path

```mermaid
flowchart TD
  U[Human Lead] --> Arch[App Architect Prompt]
  Arch --> Scaf[Full-Stack Scaffolder]
  Arch --> UI[UI/UX Specialist]
  Scaf --> Proto[(Validated Vision Prototype)]
  UI --> Proto
  Proto --> Eng[Engineering Cycle â†’ Production]
```

## Interaction Pattern

These roles reflect the Quantum Diamond principle of dividing responsibilities
into clear, composable skill domains for reliability and scale:

1. **Genesis Cycle:** All three specialists work in parallel during prototyping
2. **Handoff Point:** Specialists provide vetted feedback before engineering takeover
3. **Engineering Cycle:** Specialists ensure production readiness

This separation allows each specialist to maintain deep expertise in their domain
while collaborating seamlessly for comprehensive agent development.
--- END OF FILE docs/roles/overview.md ---

--- START OF FILE package-lock.json ---

{
  "name": "quantum-diamond",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "dependencies": {
        "gpt-tokenizer": "^3.2.0"
      }
    },
    "node_modules/gpt-tokenizer": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/gpt-tokenizer/-/gpt-tokenizer-3.2.0.tgz",
      "integrity": "sha512-QRRhzJIHcGbbdzhMGNCHhF+98RVaBaVD5+NYgyPOamqRBEqG5yN9p5j4udnY5FJnkesjdUPsikG/DO4OfJdhpQ==",
      "license": "MIT"
    }
  }
}

--- END OF FILE package-lock.json ---

--- START OF FILE package.json ---

{
  "type": "module",
  "scripts": {
    "snapshot": "node ./capture_code_snapshot.js",
    "hygiene": "node ./scripts/run-agent-hygiene.mjs",
    "hygiene:full": "npm run snapshot && npm run hygiene"
  },
  "dependencies": {
    "gpt-tokenizer": "^3.2.0"
  }
}

--- END OF FILE package.json ---

--- START OF FILE templates/TEMPLATE_REQUIREMENT.md ---

# REQ-[ID]: [Requirement Title]

- **Statement:** A clear, one-sentence statement of what the system must do.
- **Acceptance Criteria:**
  - A bulleted list of specific, testable conditions that must be met.
  - Each criterion should be verifiable.
- **Traceability:**
  - **Implemented By:** Link to ADRs, Task files, or specific code modules.
  - **Verified By:** Link to test files (e.g., `tests/test_feature.py`).
- **Status:** To Do | In Progress | Done
--- END OF FILE templates/TEMPLATE_REQUIREMENT.md ---

--- START OF FILE templates/TEMPLATE_TASK.md ---

# [ID] - [Task Title]

- **Requirement:** Link to the `REQ-ID` this task helps fulfill.
- **Goal:** A high-level description of what this task will accomplish.
- **Implementation Steps:**
  - A checklist of concrete actions to be taken.
  - Example: `[ ] Modify src/module/file.py to add new function.`
  - Example: `[ ] Create new test file tests/test_new_function.py.`
- **Definition of Done:**
  - [ ] Code is implemented.
  - [ ] Unit/integration tests are passing.
  - [ ] Documentation (if needed) is updated.
--- END OF FILE templates/TEMPLATE_TASK.md ---

--- START OF FILE templates/agent_hygiene/controlFlow.ts ---

// Push loops/polling into code, not the model.
export async function waitForSlack(predicate: () => Promise<boolean>, timeoutMs = 60000) {
  const start = Date.now();
  while (Date.now() - start < timeoutMs) {
    if (await predicate()) return true;
    await new Promise(r => setTimeout(r, 2000));
  }
  return false;
}
--- END OF FILE templates/agent_hygiene/controlFlow.ts ---

--- START OF FILE templates/agent_hygiene/controlPlane.ts ---

export interface HygieneFinding {
  severity: "error" | "warn";
  message: string;
}

export function inspectControlPlane(code: string): HygieneFinding[] {
  const findings: HygieneFinding[] = [];

  // Anti-pattern: embedding entire schemas in prompts
  if (code.includes("schema") && (code.includes("prompt") || code.includes("instruction"))) {
    findings.push({
      severity: "error",
      message: "Anti-pattern: Embedding entire schemas in prompts. Schemas should be referenced, not embedded."
    });
  }

  // Anti-pattern: unbounded "conversation memory" usage
  if (code.match(/conversation.*memory|memory.*conversation/i) && !code.includes("limit")) {
    findings.push({
      severity: "error",
      message: "Anti-pattern: Unbounded conversation memory usage detected. Implement memory limits and cleanup."
    });
  }

  // Anti-pattern: prompts referencing external state implicitly
  if (code.match(/previous.*conversation|conversation.*history|chat.*history/i) && !code.includes("explicit")) {
    findings.push({
      severity: "warn",
      message: "Anti-pattern: Prompts referencing external state implicitly. Use explicit state passing instead."
    });
  }

  // Anti-pattern: mutation of the LLM's "internal mental model"
  if (code.match(/mental.*model|internal.*state|llm.*state/i) && code.includes("mutate")) {
    findings.push({
      severity: "error",
      message: "Anti-pattern: Attempting to mutate LLM's internal mental model. Use external state management."
    });
  }

  // Detect attempts to load tools directly into prompts
  if (code.match(/load.*tool|tool.*load|embed.*tool/i) && (code.includes("prompt") || code.includes("instruction"))) {
    findings.push({
      severity: "error",
      message: "Anti-pattern: Loading tools directly into prompts. Use tool registry pattern instead."
    });
  }

  // Detect state persistence mistakes (prompt history misuse)
  if (code.match(/prompt.*history|history.*prompt/i) && code.includes("persist")) {
    findings.push({
      severity: "warn",
      message: "State persistence mistake: Misusing prompt history for persistence. Use dedicated state management."
    });
  }

  // Enforce structured object returns instead of narrative prose
  if (code.match(/return.*narrative|return.*story|return.*prose/i)) {
    findings.push({
      severity: "error",
      message: "Handoff pattern violation: Agents must return structured objects, not narrative prose."
    });
  }

  // Missing schema return types in prompts
  if ((code.includes("return") || code.includes("output")) && !code.includes("schema") && !code.includes("type")) {
    findings.push({
      severity: "warn",
      message: "Missing schema return types: Prompts should specify structured return types (JSON/Zod)."
    });
  }

  // Detect context-stuffing tendencies
  if (code.match(/context.*stuff|stuff.*context|large.*context/i)) {
    findings.push({
      severity: "warn",
      message: "Context-stuffing tendency detected. Implement context pruning and selective inclusion."
    });
  }

  return findings;
}
--- END OF FILE templates/agent_hygiene/controlPlane.ts ---

--- START OF FILE templates/agent_hygiene/dataPlane.ts ---

// Keep heavy data out of the model: store + summarize.
export async function persistBlob(path: string, bytes: Uint8Array): Promise<string> {
  // write to workspace or object storage; return pointer/URI
  return path;
}

export function summarizeTabular(rows: any[], maxRows = 50) {
  // filter/aggregate here; return compact structured view
  return { rows: rows.slice(0, maxRows), stats: {/* â€¦ */} };
}
--- END OF FILE templates/agent_hygiene/dataPlane.ts ---

--- START OF FILE templates/agent_hygiene/privacy.ts ---

// Simple redaction hook; plug into IO pipeline.
export function redactPII(text: string): string {
  return text
    .replace(/\b\d{3}-\d{3}-\d{4}\b/g, "[phone]")
    .replace(/\b[\w.-]+@[\w.-]+\.\w+\b/g, "[email]");
}
--- END OF FILE templates/agent_hygiene/privacy.ts ---

--- START OF FILE templates/agent_hygiene/toolRegistry.ts ---

// JIT tool registry: no context-stuffing of schemas.
export type Tool = { name: string; schema: unknown; run: (input: any) => Promise<any> };

export async function discoverTools(dir = "./tools"): Promise<Record<string, Tool>> {
  const reg: Record<string, Tool> = {};
  // Pseudo: load *.tool.(ts|js) modules; each exports { name, schema, run }
  // Avoid loading full schemas into prompts; feed only names/caps until selected.
  return reg;
}

export function selectTools(reg: Record<string, Tool>, needs: string[]): Tool[] {
  return needs.map(n => reg[n]).filter(Boolean);
}
--- END OF FILE templates/agent_hygiene/toolRegistry.ts ---

