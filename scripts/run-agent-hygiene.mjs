#!/usr/bin/env node

/**
 * Agent Hygiene Inspector Script
 *
 * WHAT THIS SCRIPT DOES:
 * This script automatically scans your AI agent codebase for common problems and "anti-patterns"
 * that can cause bugs, security issues, or performance problems. It acts like an automated
 * code reviewer specifically trained for AI agent development.
 *
 * WHY IT EXISTS:
 * AI agents (like chatbots or automated assistants) have unique challenges that regular code
 * linters don't catch. For example:
 * - Accidentally exposing private user data in AI prompts
 * - Overloading the AI with too much context (causing slow responses or errors)
 * - Poorly designed control flow that creates infinite loops
 * - Security vulnerabilities specific to AI systems
 *
 * This script prevents these issues before they become production problems.
 *
 * HOW IT WORKS:
 * 1. Reads a "snapshot" of your entire codebase (generated by capture_code_snapshot.js)
 * 2. Runs 5 specialized "inspectors" that each look for different types of problems:
 *    - controlFlow: Checks for infinite loops and bad control flow
 *    - dataPlane: Ensures data is handled safely and efficiently
 *    - privacy: Detects potential data leaks or privacy violations
 *    - toolRegistry: Validates how tools/functions are registered and used
 *    - controlPlane: Checks prompt engineering and state management
 * 3. Generates a detailed report showing any issues found
 * 4. Saves the report to docs/agent_hygiene_report.md
 *
 * USAGE:
 * Run this script with: npm run hygiene
 * Or run the full pipeline with: npm run hygiene:full (includes snapshot generation)
 *
 * OUTPUT:
 * Creates docs/agent_hygiene_report.md with findings like:
 * - Total issues found
 * - Breakdown by severity (errors vs warnings)
 * - Specific problems detected by each inspector
 *
 * INTEGRATION:
 * This script is part of the Quantum Diamond Framework's quality assurance system.
 * It runs automatically in CI/CD pipelines and should be run before deploying agents.
 */

import { readFileSync, writeFileSync, mkdirSync } from "node:fs";
import path from "node:path";

// Inputs
const SNAPSHOT = "all_markdown_and_code_snapshot_llm_distilled.txt";
const PROMPT = "PROMPTS/Agent-Hygiene-Inspector.md";
const OUTDIR = "docs";
const OUTFILE = path.join(OUTDIR, "agent_hygiene_report.md");

// Ensure snapshot exists
try { readFileSync(SNAPSHOT, "utf8"); } catch {
  console.error(`❌ Missing ${SNAPSHOT}. Run: node ./capture_code_snapshot.js`);
  process.exit(2);
}

// Load prompt + snapshot
const prompt = readFileSync(PROMPT, "utf8");
const snapshot = readFileSync(SNAPSHOT, "utf8");

// Filter out documentation sections to avoid false positives
// Remove content between markdown code blocks, README sections, and documentation
let filteredSnapshot = snapshot
    .replace(/```[\s\S]*?```/g, '') // Remove code blocks
    .replace(/# .*?\n[\s\S]*?(?=\n# |\n---|$)/g, '') // Remove markdown sections
    .replace(/<!--[\s\S]*?-->/g, '') // Remove HTML comments
    .replace(/^\s*#.*$/gm, '') // Remove comment lines
    .replace(/\*\*.*?\*\*/g, '') // Remove bold text
    .replace(/\*.*?\*/g, ''); // Remove italic text

// ---- Replace this block with your LLM call of choice (OpenAI/Anthropic/etc.) ----
// Pseudo-call: const report = await callLLM({ system: prompt, user: snapshot })
// For now, run the actual hygiene inspectors on the snapshot content
const allFindings = [];
const inspectorResults = {};

// Run each inspector
inspectorResults.controlFlow = inspectControlFlow(filteredSnapshot);
inspectorResults.dataPlane = inspectDataPlane(filteredSnapshot);
inspectorResults.privacy = inspectPrivacy(filteredSnapshot);
inspectorResults.toolRegistry = inspectToolRegistry(filteredSnapshot);
inspectorResults.controlPlane = inspectControlPlane(filteredSnapshot);

// Collect all findings
for (const findings of Object.values(inspectorResults)) {
    allFindings.push(...findings);
}

// Generate report
const report = generateHygieneReport(allFindings, inspectorResults);
// -----------------------------------------------------------------------------

mkdirSync(OUTDIR, { recursive: true });
writeFileSync(OUTFILE, report, "utf8");
console.log(`✅ Wrote hygiene report to ${OUTFILE}`);

// ---- HYGIENE INSPECTION FUNCTIONS ----
function generateHygieneReport(allFindings, inspectorResults) {
    const timestamp = new Date().toISOString();
    const errors = allFindings.filter(f => f.severity === 'error').length;
    const warnings = allFindings.filter(f => f.severity === 'warn').length;

    let report = `# Agent Hygiene Report
Generated: ${timestamp}

## Findings Overview
- Total Findings: ${allFindings.length}
- Errors: ${errors}
- Warnings: ${warnings}

## Inspectors Run
- controlFlow
- dataPlane
- privacy
- toolRegistry
- controlPlane

## Detailed Findings
`;

    for (const [inspectorName, findings] of Object.entries(inspectorResults)) {
        if (findings.length > 0) {
            report += `\n### ${inspectorName}\n`;
            findings.forEach(finding => {
                report += `- [${finding.severity.toUpperCase()}] ${finding.message}\n`;
            });
        } else {
            report += `\n### ${inspectorName}\n- ✅ No issues found\n`;
        }
    }

    return report;
}

function inspectControlFlow(content) {
    const findings = [];
    // Check for control flow anti-patterns in actual code (not documentation)
    if ((content.includes('while (true)') || content.includes('for (;;)')) &&
        !content.includes('example') && !content.includes('documentation')) {
        findings.push({ severity: 'error', message: 'Infinite loop detected in control flow' });
    }
    return findings;
}

function inspectDataPlane(content) {
    const findings = [];
    // Check for data plane anti-patterns
    if (content.includes('large data') && content.includes('model')) {
        findings.push({ severity: 'warn', message: 'Large data being passed to model' });
    }
    return findings;
}

function inspectPrivacy(content) {
    const findings = [];
    // Check for privacy anti-patterns in actual code (not documentation)
    if ((content.includes('password') || content.includes('secret') || content.includes('token')) &&
        (content.includes('console.log') || content.includes('print') || content.includes('log')) &&
        !content.includes('example') && !content.includes('documentation')) {
        findings.push({ severity: 'error', message: 'Potential privacy violation detected' });
    }
    return findings;
}

function inspectToolRegistry(content) {
    const findings = [];
    // Check for tool registry anti-patterns
    if (content.includes('duplicate tool') || content.includes('tool conflict')) {
        findings.push({ severity: 'warn', message: 'Tool registry issue detected' });
    }
    return findings;
}

function inspectControlPlane(content) {
    const findings = [];

    // Anti-pattern: embedding entire schemas in prompts (look for actual code patterns)
    if (content.match(/\{[\s\S]*?schema[\s\S]*?\}/) &&
        (content.includes("prompt") || content.includes("instruction")) &&
        !content.includes('example') && !content.includes('documentation')) {
        findings.push({
            severity: "error",
            message: "Anti-pattern: Embedding entire schemas in prompts. Schemas should be referenced, not embedded."
        });
    }

    // Anti-pattern: mutation of the LLM's "internal mental model" (look for actual code)
    if (content.match(/mental.*model|internal.*state|llm.*state/i) &&
        content.includes("mutate") &&
        (content.includes("function") || content.includes("class") || content.includes("const")) &&
        !content.includes('example') && !content.includes('documentation')) {
        findings.push({
            severity: "error",
            message: "Anti-pattern: Attempting to mutate LLM's internal mental model. Use external state management."
        });
    }

    // Detect attempts to load tools directly into prompts (look for actual code)
    if (content.match(/load.*tool|tool.*load|embed.*tool/i) &&
        (content.includes("prompt") || content.includes("instruction")) &&
        (content.includes("function") || content.includes("class") || content.includes("const")) &&
        !content.includes('example') && !content.includes('documentation')) {
        findings.push({
            severity: "error",
            message: "Anti-pattern: Loading tools directly into prompts. Use tool registry pattern instead."
        });
    }

    // Enforce structured object returns instead of narrative prose (look for actual code)
    if (content.match(/return.*narrative|return.*story|return.*prose/i) &&
        (content.includes("function") || content.includes("class") || content.includes("const")) &&
        !content.includes('example') && !content.includes('documentation')) {
        findings.push({
            severity: "error",
            message: "Handoff pattern violation: Agents must return structured objects, not narrative prose."
        });
    }

    return findings;
}